{"version":3,"sources":["src/common.speech/SynthesisAdapterBase.ts"],"names":[],"mappings":"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","file":"SynthesisAdapterBase.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ArgumentNullError,\r\n    ConnectionClosedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    EventSource,\r\n    IAudioDestination,\r\n    IConnection,\r\n    IDisposable,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SpeechSynthesisBookmarkEventArgs,\r\n    SpeechSynthesisEventArgs,\r\n    SpeechSynthesisResult,\r\n    SpeechSynthesisVisemeEventArgs,\r\n    SpeechSynthesisWordBoundaryEventArgs,\r\n    SpeechSynthesizer,\r\n} from \"../sdk/Exports\";\r\nimport {\r\n    AgentConfig,\r\n    CancellationErrorCodePropertyName,\r\n    ISynthesisConnectionFactory,\r\n    MetadataType,\r\n    SynthesisAudioMetadata,\r\n    SynthesisContext,\r\n    SynthesisTurn,\r\n    SynthesizerConfig\r\n} from \"./Exports\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class SynthesisAdapterBase implements IDisposable {\r\n    protected privSynthesisTurn: SynthesisTurn;\r\n    protected privConnectionId: string;\r\n    protected privSynthesizerConfig: SynthesizerConfig;\r\n    protected privSpeechSynthesizer: SpeechSynthesizer;\r\n    protected privSuccessCallback: (e: SpeechSynthesisResult) => void;\r\n    protected privErrorCallback: (e: string) => void;\r\n\r\n    public get synthesisContext(): SynthesisContext {\r\n        return this.privSynthesisContext;\r\n    }\r\n\r\n    public get agentConfig(): AgentConfig {\r\n        return this.privAgentConfig;\r\n    }\r\n\r\n    public get connectionEvents(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    public get serviceEvents(): EventSource<ServiceEvent> {\r\n        return this.privServiceEvents;\r\n    }\r\n\r\n    protected speakOverride: (ssml: string, requestId: string, sc: (e: SpeechSynthesisResult) => void, ec: (e: string) => void) => any = undefined;\r\n\r\n    // Called when telemetry data is sent to the service.\r\n    // Used for testing Telemetry capture.\r\n    public static telemetryData: (json: string) => void;\r\n    public static telemetryDataEnabled: boolean = true;\r\n\r\n    public set activityTemplate(messagePayload: string) { this.privActivityTemplate = messagePayload; }\r\n    public get activityTemplate(): string { return this.privActivityTemplate; }\r\n\r\n    protected receiveMessageOverride: () => any = undefined;\r\n\r\n    protected connectImplOverride: (isUnAuthorized: boolean) => any = undefined;\r\n\r\n    protected configConnectionOverride: (connection: IConnection) => any = undefined;\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n        this.privSynthesisTurn.audioOutputFormat = format;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.format = format;\r\n        }\r\n        if (this.synthesisContext !== undefined) {\r\n            this.synthesisContext.audioOutputFormat = format;\r\n        }\r\n    }\r\n    private privAuthentication: IAuthentication;\r\n    private privConnectionFactory: ISynthesisConnectionFactory;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionConfigurationPromise: Promise<IConnection>;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionPromise: Promise<IConnection>;\r\n    private privAuthFetchEventId: string;\r\n    private privIsDisposed: boolean;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privServiceEvents: EventSource<ServiceEvent>;\r\n    private privSynthesisContext: SynthesisContext;\r\n    private privAgentConfig: AgentConfig;\r\n    private privServiceHasSentMessage: boolean;\r\n    private privActivityTemplate: string;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privSessionAudioDestination: IAudioDestination;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: ISynthesisConnectionFactory,\r\n        synthesizerConfig: SynthesizerConfig,\r\n        speechSynthesizer: SpeechSynthesizer,\r\n        audioDestination: IAudioDestination) {\r\n\r\n        if (!authentication) {\r\n            throw new ArgumentNullError(\"authentication\");\r\n        }\r\n\r\n        if (!connectionFactory) {\r\n            throw new ArgumentNullError(\"connectionFactory\");\r\n        }\r\n\r\n        if (!synthesizerConfig) {\r\n            throw new ArgumentNullError(\"synthesizerConfig\");\r\n        }\r\n\r\n        this.privAuthentication = authentication;\r\n        this.privConnectionFactory = connectionFactory;\r\n        this.privSynthesizerConfig = synthesizerConfig;\r\n        this.privIsDisposed = false;\r\n        this.privSpeechSynthesizer = speechSynthesizer;\r\n        this.privSessionAudioDestination = audioDestination;\r\n        this.privSynthesisTurn = new SynthesisTurn();\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privServiceEvents = new EventSource<ServiceEvent>();\r\n        this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\r\n        this.privAgentConfig = new AgentConfig();\r\n\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\r\n                if (connectionClosedEvent.statusCode !== 1000) {\r\n                    this.cancelSynthesisLocal(CancellationReason.Error,\r\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\r\n                        connectionClosedEvent.reason + \" websocket error code: \" + connectionClosedEvent.statusCode);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public static addHeader(audio: ArrayBuffer, format: AudioOutputFormatImpl): ArrayBuffer {\r\n        if (!format.hasHeader) {\r\n            return audio;\r\n        }\r\n        format.updateHeader(audio.byteLength);\r\n        const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\r\n        tmp.set(new Uint8Array(format.header), 0);\r\n        tmp.set(new Uint8Array(audio), format.header.byteLength);\r\n        return tmp.buffer;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privIsDisposed = true;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.close();\r\n        }\r\n        if (this.privConnectionConfigurationPromise) {\r\n            const connection: IConnection = await this.privConnectionConfigurationPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n    }\r\n\r\n    public async connect(): Promise<void> {\r\n        await this.connectImpl();\r\n    }\r\n\r\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\r\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\r\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\r\n    }\r\n\r\n    public async Speak(\r\n        text: string,\r\n        isSSML: boolean,\r\n        requestId: string,\r\n        successCallback: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack: (e: string) => void,\r\n        audioDestination: IAudioDestination,\r\n    ): Promise<void> {\r\n\r\n        let ssml: string;\r\n\r\n        if (isSSML) {\r\n            ssml = text;\r\n        } else {\r\n            ssml = this.privSpeechSynthesizer.buildSsml(text);\r\n        }\r\n\r\n        if (this.speakOverride !== undefined) {\r\n            return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\r\n        }\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallBack;\r\n\r\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\r\n\r\n        try {\r\n            await this.connectImpl();\r\n            const connection: IConnection = await this.fetchConnection();\r\n            await this.sendSynthesisContext(connection);\r\n            await this.sendSsmlMessage(connection, ssml, requestId);\r\n            const synthesisStartEventArgs: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                new SpeechSynthesisResult(\r\n                    requestId,\r\n                    ResultReason.SynthesizingAudioStarted,\r\n                )\r\n            );\r\n\r\n            if (!!this.privSpeechSynthesizer.synthesisStarted) {\r\n                this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\r\n            }\r\n\r\n            const messageRetrievalPromise = this.receiveMessage();\r\n        } catch (e) {\r\n            this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesis(\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n        const result: SpeechSynthesisResult = new SpeechSynthesisResult(\r\n            requestId,\r\n            ResultReason.Canceled,\r\n            undefined,\r\n            error,\r\n            properties\r\n        );\r\n\r\n        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\r\n            const cancelEvent: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(result);\r\n            try {\r\n                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n        }\r\n\r\n        if (!!this.privSuccessCallback) {\r\n            try {\r\n                this.privSuccessCallback(result);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesisLocal(\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        if (!!this.privSynthesisTurn.isSynthesizing) {\r\n            this.privSynthesisTurn.onStopSynthesizing();\r\n\r\n            this.cancelSynthesis(\r\n                this.privSynthesisTurn.requestId,\r\n                cancellationReason,\r\n                errorCode,\r\n                error);\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(\r\n        connectionMessage: SpeechConnectionMessage,\r\n        successCallback?: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack?: (e: string) => void): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected async receiveMessage(): Promise<void> {\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConnectionMessage = await connection.read();\r\n\r\n            if (this.receiveMessageOverride !== undefined) {\r\n                return this.receiveMessageOverride();\r\n            }\r\n            if (this.privIsDisposed) {\r\n                // We're done.\r\n                return;\r\n            }\r\n\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!message) {\r\n                if (!this.privSynthesisTurn.isSynthesizing) {\r\n                    return;\r\n                } else {\r\n                    return this.receiveMessage();\r\n                }\r\n            }\r\n\r\n            this.privServiceHasSentMessage = true;\r\n\r\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n            if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        this.privSynthesisTurn.onServiceTurnStartResponse();\r\n                        break;\r\n                    case \"response\":\r\n                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\r\n                        break;\r\n                    case \"audio\":\r\n                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\r\n                            && !!connectionMessage.binaryBody) {\r\n                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\r\n                            if (!!this.privSpeechSynthesizer.synthesizing) {\r\n                                try {\r\n                                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\r\n                                    const ev: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                                        new SpeechSynthesisResult(\r\n                                            this.privSynthesisTurn.requestId,\r\n                                            ResultReason.SynthesizingAudio,\r\n                                            audioWithHeader));\r\n                                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\r\n                                } catch (error) {\r\n                                    // Not going to let errors in the event handler\r\n                                    // trip things up.\r\n                                }\r\n                            }\r\n                            if (this.privSessionAudioDestination !== undefined) {\r\n                                this.privSessionAudioDestination.write(connectionMessage.binaryBody);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"audio.metadata\":\r\n                        const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\r\n                        for (const metadata of metadataList) {\r\n                            switch (metadata.Type) {\r\n                                case MetadataType.WordBoundary:\r\n                                    this.privSynthesisTurn.onWordBoundaryEvent(metadata.Data.text.Text);\r\n\r\n                                    const wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.text.Text,\r\n                                        metadata.Data.text.Length,\r\n                                        this.privSynthesisTurn.currentTextOffset);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.wordBoundary) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Bookmark:\r\n                                    const bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Bookmark);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Viseme:\r\n\r\n                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\r\n\r\n                                    if (metadata.Data.IsLastAnimation) {\r\n                                        const visemeEventArgs: SpeechSynthesisVisemeEventArgs = new SpeechSynthesisVisemeEventArgs(\r\n                                            metadata.Data.Offset,\r\n                                            metadata.Data.VisemeId,\r\n                                            this.privSynthesisTurn.getAndClearVisemeAnimation());\r\n\r\n                                        if (!!this.privSpeechSynthesizer.visemeReceived) {\r\n                                            try {\r\n                                                this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\r\n                                            } catch (error) {\r\n                                                // Not going to let errors in the event handler\r\n                                                // trip things up.\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"turn.end\":\r\n                        this.privSynthesisTurn.onServiceTurnEndResponse();\r\n                        let result: SpeechSynthesisResult;\r\n                        try {\r\n                            const audioBuffer: ArrayBuffer = await this.privSynthesisTurn.getAllReceivedAudioWithHeader();\r\n                            result = new SpeechSynthesisResult(\r\n                                this.privSynthesisTurn.requestId,\r\n                                ResultReason.SynthesizingAudioCompleted,\r\n                                audioBuffer\r\n                            );\r\n                            if (!!this.privSuccessCallback) {\r\n                                this.privSuccessCallback(result);\r\n                            }\r\n                        } catch (error) {\r\n                            if (!!this.privErrorCallback) {\r\n                                this.privErrorCallback(error);\r\n                            }\r\n                        }\r\n                        if (this.privSpeechSynthesizer.synthesisCompleted) {\r\n                            try {\r\n                                this.privSpeechSynthesizer.synthesisCompleted(\r\n                                    this.privSpeechSynthesizer,\r\n                                    new SpeechSynthesisEventArgs(result)\r\n                                );\r\n                            } catch (e) {\r\n                                // Not going to let errors in the event handler\r\n                                // trip things up.\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\r\n                            if (!!this.privServiceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n\r\n                }\r\n            }\r\n\r\n            return this.receiveMessage();\r\n\r\n        } catch (e) {\r\n            // TODO: What goes here?\r\n        }\r\n    }\r\n\r\n    protected sendSynthesisContext = (connection: IConnection): Promise<void> => {\r\n        const synthesisContextJson = this.synthesisContext.toJSON();\r\n\r\n        if (synthesisContextJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"synthesis.context\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                synthesisContextJson));\r\n        }\r\n        return;\r\n    }\r\n\r\n    protected connectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n        if (this.privConnectionPromise) {\r\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionPromise = null;\r\n                    this.privServiceHasSentMessage = false;\r\n                    return this.connectImpl();\r\n                }\r\n                return this.privConnectionPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionPromise = null;\r\n                this.privServiceHasSentMessage = false;\r\n                return this.connectImpl();\r\n            });\r\n        }\r\n        this.privAuthFetchEventId = createNoDashGuid();\r\n        this.privConnectionId = createNoDashGuid();\r\n\r\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\r\n\r\n        this.privConnectionPromise = authPromise.then(async (result: AuthInfo) => {\r\n            await this.privSynthesisTurn.onAuthCompleted(false);\r\n\r\n            const connection: IConnection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\r\n\r\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n            // it'll stop sending events.\r\n            connection.events.attach((event: ConnectionEvent) => {\r\n                this.connectionEvents.onEvent(event);\r\n            });\r\n            const response = await connection.open();\r\n            if (response.statusCode === 200) {\r\n                await this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.resolve(connection);\r\n            } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                return this.connectImpl(true);\r\n            } else {\r\n                await this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n            }\r\n        }, async (error: string): Promise<IConnection> => {\r\n            await this.privSynthesisTurn.onAuthCompleted(true, error);\r\n            throw new Error(error);\r\n        });\r\n\r\n        // Attach an empty handler to allow the promise to run in the background while\r\n        // other startup events happen. It'll eventually be awaited on.\r\n        this.privConnectionPromise.catch(() => { });\r\n\r\n        return this.privConnectionPromise;\r\n    }\r\n    protected sendSpeechServiceConfig = (connection: IConnection, SpeechServiceConfigJson: string): Promise<void> => {\r\n        if (SpeechServiceConfigJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"speech.config\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                SpeechServiceConfigJson));\r\n        }\r\n    }\r\n\r\n    protected sendSsmlMessage = (connection: IConnection, ssml: string, requestId: string): Promise<void> => {\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"ssml\",\r\n            requestId,\r\n            \"application/ssml+xml\",\r\n            ssml));\r\n    }\r\n\r\n    private async fetchConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigurationPromise) {\r\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigurationPromise = null;\r\n                    this.privServiceHasSentMessage = false;\r\n                    return this.fetchConnection();\r\n                }\r\n                return this.privConnectionConfigurationPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigurationPromise = null;\r\n                this.privServiceHasSentMessage = false;\r\n                return this.fetchConnection();\r\n            });\r\n        }\r\n        this.privConnectionConfigurationPromise = this.configureConnection();\r\n        return await this.privConnectionConfigurationPromise;\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configureConnection(): Promise<IConnection> {\r\n        const connection: IConnection = await this.connectImpl();\r\n        if (this.configConnectionOverride !== undefined) {\r\n            return this.configConnectionOverride(connection);\r\n        }\r\n        await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\r\n        return connection;\r\n    }\r\n}\r\n"]}