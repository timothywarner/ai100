{"version":3,"sources":["src/common.browser/CertChecks.ts"],"names":[],"mappings":"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","file":"CertChecks.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport * as http from \"http\";\r\nimport * as tls from \"tls\";\r\nimport * as parse from \"url-parse\";\r\nimport * as ocsp from \"../../external/ocsp/ocsp\";\r\nimport {\r\n    Events,\r\n    OCSPCacheEntryExpiredEvent,\r\n    OCSPCacheEntryNeedsRefreshEvent,\r\n    OCSPCacheFetchErrorEvent,\r\n    OCSPCacheHitEvent,\r\n    OCSPCacheMissEvent,\r\n    OCSPCacheUpdatehCompleteEvent,\r\n    OCSPCacheUpdateNeededEvent,\r\n    OCSPDiskCacheHitEvent,\r\n    OCSPDiskCacheStoreEvent,\r\n    OCSPEvent,\r\n    OCSPMemoryCacheHitEvent,\r\n    OCSPMemoryCacheStoreEvent,\r\n    OCSPResponseRetrievedEvent,\r\n    OCSPStapleReceivedEvent,\r\n    OCSPVerificationFailedEvent,\r\n} from \"../common/Exports\";\r\nimport { IStringDictionary } from \"../common/IDictionary\";\r\nimport { ProxyInfo } from \"./ProxyInfo\";\r\n\r\nimport Agent from \"agent-base\";\r\n\r\n// @ts-ignore\r\nimport Cache from \"async-disk-cache\";\r\nimport HttpsProxyAgent from \"https-proxy-agent\";\r\nimport * as net from \"net\";\r\nimport { OCSPCacheUpdateErrorEvent } from \"../common/OCSPEvents\";\r\n\r\nexport class CertCheckAgent {\r\n\r\n    // Test hook to enable forcing expiration / refresh to happen.\r\n    public static testTimeOffset: number = 0;\r\n\r\n    // Test hook to disable stapling for cache testing.\r\n    public static forceDisableOCSPStapling: boolean = false;\r\n\r\n    // An in memory cache for recived responses.\r\n    private static privMemCache: IStringDictionary<Buffer> = {};\r\n\r\n    // The on disk cache.\r\n    private static privDiskCache: Cache;\r\n\r\n    private privProxyInfo: ProxyInfo;\r\n\r\n    constructor(proxyInfo?: ProxyInfo) {\r\n        if (!!proxyInfo) {\r\n            this.privProxyInfo = proxyInfo;\r\n        }\r\n\r\n        // Initialize this here to allow tests to set the env variable before the cache is constructed.\r\n        if (!CertCheckAgent.privDiskCache) {\r\n            CertCheckAgent.privDiskCache = new Cache(\"microsoft-cognitiveservices-speech-sdk-cache\", { supportBuffer: true, location: (typeof process !== \"undefined\" && !!process.env.SPEECH_OCSP_CACHE_ROOT) ? process.env.SPEECH_OCSP_CACHE_ROOT : undefined });\r\n        }\r\n    }\r\n\r\n    // Test hook to force the disk cache to be recreated.\r\n    public static forceReinitDiskCache(): void {\r\n        CertCheckAgent.privDiskCache = undefined;\r\n        CertCheckAgent.privMemCache = {};\r\n    }\r\n\r\n    public GetAgent(disableStapling?: boolean): http.Agent {\r\n        const agent: any = new Agent.Agent(this.CreateConnection);\r\n\r\n        if (this.privProxyInfo !== undefined &&\r\n            this.privProxyInfo.HostName !== undefined &&\r\n            this.privProxyInfo.Port > 0) {\r\n            const proxyName: string = \"privProxyInfo\";\r\n            agent[proxyName] = this.privProxyInfo;\r\n        }\r\n\r\n        return agent;\r\n    }\r\n\r\n    private static GetProxyAgent(proxyInfo: ProxyInfo): HttpsProxyAgent {\r\n        const httpProxyOptions: HttpsProxyAgent.HttpsProxyAgentOptions = {\r\n            host: proxyInfo.HostName,\r\n            port: proxyInfo.Port,\r\n        };\r\n\r\n        if (!!proxyInfo.UserName) {\r\n            httpProxyOptions.headers = {\r\n                \"Proxy-Authentication\": \"Basic \" + new Buffer(proxyInfo.UserName + \":\" + (proxyInfo.Password === undefined) ? \"\" : proxyInfo.Password).toString(\"base64\"),\r\n            };\r\n        } else {\r\n            httpProxyOptions.headers = {};\r\n        }\r\n\r\n        httpProxyOptions.headers.requestOCSP = \"true\";\r\n\r\n        const httpProxyAgent: HttpsProxyAgent = new HttpsProxyAgent(httpProxyOptions);\r\n        return httpProxyAgent;\r\n    }\r\n\r\n    private static async OCSPCheck(socketPromise: Promise<net.Socket>, proxyInfo: ProxyInfo): Promise<net.Socket> {\r\n        let ocspRequest: ocsp.Request;\r\n        let stapling: Buffer;\r\n        let resolved: boolean = false;\r\n\r\n        const socket: net.Socket = await socketPromise;\r\n        socket.cork();\r\n\r\n        const tlsSocket: tls.TLSSocket = socket as tls.TLSSocket;\r\n\r\n        return new Promise<net.Socket>((resolve: (value: net.Socket) => void, reject: (error: string | Error) => void) => {\r\n            socket.on(\"OCSPResponse\", (data: Buffer): void => {\r\n                if (!!data) {\r\n                    this.onEvent(new OCSPStapleReceivedEvent());\r\n                    stapling = data;\r\n                }\r\n            });\r\n\r\n            socket.on(\"error\", (error: Error) => {\r\n                if (!resolved) {\r\n                    resolved = true;\r\n                    socket.destroy();\r\n                    reject(error);\r\n                }\r\n            });\r\n\r\n            tlsSocket.on(\"secure\", async () => {\r\n                const peer: tls.DetailedPeerCertificate = tlsSocket.getPeerCertificate(true);\r\n                try {\r\n                    const issuer: tls.DetailedPeerCertificate = await this.GetIssuer(peer);\r\n\r\n                    // We always need a request to verify the response.\r\n                    ocspRequest = ocsp.request.generate(peer.raw, issuer.raw);\r\n\r\n                    // Do we have a result for this certificate in our memory cache?\r\n                    const sig: string = ocspRequest.id.toString(\"hex\");\r\n\r\n                    // Stapled response trumps cached response.\r\n                    if (!stapling) {\r\n                        const cacheEntry: Buffer = await CertCheckAgent.GetResponseFromCache(sig, ocspRequest, proxyInfo);\r\n                        stapling = cacheEntry;\r\n                    }\r\n\r\n                    await this.VerifyOCSPResponse(stapling, ocspRequest, proxyInfo);\r\n\r\n                    socket.uncork();\r\n                    resolved = true;\r\n                    resolve(socket);\r\n                } catch (e) {\r\n                    socket.destroy();\r\n                    resolved = true;\r\n                    reject(e);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private static GetIssuer(peer: tls.DetailedPeerCertificate): Promise<tls.DetailedPeerCertificate> {\r\n        if (peer.issuerCertificate) {\r\n            return Promise.resolve(peer.issuerCertificate);\r\n        }\r\n\r\n        return new Promise<tls.DetailedPeerCertificate>((resolve: (value: tls.DetailedPeerCertificate) => void, reject: (reason: string) => void) => {\r\n            const ocspAgent: ocsp.Agent = new ocsp.Agent({});\r\n            ocspAgent.fetchIssuer(peer, null, (error: string, value: tls.DetailedPeerCertificate): void => {\r\n                if (!!error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                resolve(value);\r\n            });\r\n        });\r\n    }\r\n\r\n    private static async GetResponseFromCache(signature: string, ocspRequest: ocsp.Request, proxyInfo: ProxyInfo): Promise<Buffer> {\r\n        let cachedResponse: Buffer = CertCheckAgent.privMemCache[signature];\r\n\r\n        if (!!cachedResponse) {\r\n            this.onEvent(new OCSPMemoryCacheHitEvent(signature));\r\n        }\r\n\r\n        // Do we have a result for this certificate on disk in %TMP%?\r\n        if (!cachedResponse) {\r\n            try {\r\n                const diskCacheResponse: any = await CertCheckAgent.privDiskCache.get(signature);\r\n                if (!!diskCacheResponse.isCached) {\r\n                    CertCheckAgent.onEvent(new OCSPDiskCacheHitEvent(signature));\r\n                    CertCheckAgent.StoreMemoryCacheEntry(signature, diskCacheResponse.value);\r\n                    cachedResponse = diskCacheResponse.value;\r\n                }\r\n            } catch (error) {\r\n                cachedResponse = null;\r\n            }\r\n        }\r\n\r\n        if (!cachedResponse) {\r\n            return cachedResponse;\r\n        }\r\n\r\n        try {\r\n            const cachedOcspResponse: ocsp.Response = ocsp.utils.parseResponse(cachedResponse);\r\n            const tbsData = cachedOcspResponse.value.tbsResponseData;\r\n            if (tbsData.responses.length < 1) {\r\n                this.onEvent(new OCSPCacheFetchErrorEvent(signature, \"Not enough data in cached response\"));\r\n                return;\r\n            }\r\n\r\n            const cachedStartTime: number = tbsData.responses[0].thisUpdate;\r\n            const cachedNextTime: number = tbsData.responses[0].nextUpdate;\r\n\r\n            if (cachedNextTime < (Date.now() + this.testTimeOffset - 60000)) {\r\n                // Cached entry has expired.\r\n                this.onEvent(new OCSPCacheEntryExpiredEvent(signature, cachedNextTime));\r\n                cachedResponse = null;\r\n            } else {\r\n                // If we're within one day of the next update, or 50% of the way through the validity period,\r\n                // background an update to the cache.\r\n\r\n                const minUpdate: number = Math.min(24 * 60 * 60 * 1000, (cachedNextTime - cachedStartTime) / 2);\r\n\r\n                if ((cachedNextTime - (Date.now() + this.testTimeOffset)) < minUpdate) {\r\n                    this.onEvent(new OCSPCacheEntryNeedsRefreshEvent(signature, cachedStartTime, cachedNextTime));\r\n                    this.UpdateCache(ocspRequest, proxyInfo).catch((error: string) => {\r\n                        // Well, not much we can do here.\r\n                        this.onEvent(new OCSPCacheUpdateErrorEvent(signature, error.toString()));\r\n                    });\r\n                } else {\r\n                    this.onEvent(new OCSPCacheHitEvent(signature, cachedStartTime, cachedNextTime));\r\n                }\r\n            }\r\n        } catch (error) {\r\n            this.onEvent(new OCSPCacheFetchErrorEvent(signature, error));\r\n            cachedResponse = null;\r\n        }\r\n        if (!cachedResponse) {\r\n            this.onEvent(new OCSPCacheMissEvent(signature));\r\n        }\r\n        return cachedResponse;\r\n    }\r\n\r\n    private static async VerifyOCSPResponse(cacheValue: Buffer, ocspRequest: ocsp.Request, proxyInfo: ProxyInfo): Promise<void> {\r\n        let ocspResponse: Buffer = cacheValue;\r\n        const sig: string = ocspRequest.certID.toString(\"hex\");\r\n\r\n        // Do we have a valid response?\r\n        if (!ocspResponse) {\r\n            ocspResponse = await CertCheckAgent.GetOCSPResponse(ocspRequest, proxyInfo);\r\n        }\r\n\r\n        return new Promise<void>((resolve: () => void, reject: (error: string | Error) => void) => {\r\n            ocsp.verify({ request: ocspRequest, response: ocspResponse }, (error: string, result: any): void => {\r\n                if (!!error) {\r\n                    CertCheckAgent.onEvent(new OCSPVerificationFailedEvent(ocspRequest.id.toString(\"hex\"), error));\r\n\r\n                    // Bad Cached Value? One more try without the cache.\r\n                    if (!!cacheValue) {\r\n                        this.VerifyOCSPResponse(null, ocspRequest, proxyInfo).then(() => {\r\n                            resolve();\r\n                        }, (error: Error) => {\r\n                            reject(error);\r\n                        });\r\n                    } else {\r\n                        reject(error);\r\n                    }\r\n                } else {\r\n                    if (!cacheValue) {\r\n                        CertCheckAgent.StoreCacheEntry(ocspRequest.id.toString(\"hex\"), ocspResponse);\r\n                    }\r\n                    resolve();\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private static async UpdateCache(req: ocsp.Request, proxyInfo: ProxyInfo): Promise<void> {\r\n        const signature: string = req.id.toString(\"hex\");\r\n        this.onEvent(new OCSPCacheUpdateNeededEvent(signature));\r\n\r\n        const rawResponse: Buffer = await this.GetOCSPResponse(req, proxyInfo);\r\n        this.StoreCacheEntry(signature, rawResponse);\r\n        this.onEvent(new OCSPCacheUpdatehCompleteEvent(req.id.toString(\"hex\")));\r\n\r\n    }\r\n\r\n    private static StoreCacheEntry(sig: string, rawResponse: Buffer): void {\r\n        this.StoreMemoryCacheEntry(sig, rawResponse);\r\n        this.StoreDiskCacheEntry(sig, rawResponse);\r\n    }\r\n\r\n    private static StoreMemoryCacheEntry(sig: string, rawResponse: Buffer): void {\r\n        this.privMemCache[sig] = rawResponse;\r\n        this.onEvent(new OCSPMemoryCacheStoreEvent(sig));\r\n    }\r\n\r\n    private static StoreDiskCacheEntry(sig: string, rawResponse: Buffer): void {\r\n        this.privDiskCache.set(sig, rawResponse).then(() => {\r\n            this.onEvent(new OCSPDiskCacheStoreEvent(sig));\r\n        });\r\n    }\r\n\r\n    private static GetOCSPResponse(req: ocsp.Request, proxyInfo: ProxyInfo): Promise<Buffer> {\r\n\r\n        const ocspMethod: string = \"1.3.6.1.5.5.7.48.1\";\r\n        let options: http.RequestOptions = {};\r\n\r\n        if (!!proxyInfo) {\r\n            const agent: HttpsProxyAgent = CertCheckAgent.GetProxyAgent(proxyInfo);\r\n            options.agent = agent;\r\n        }\r\n\r\n        return new Promise<Buffer>((resolve: (value: Buffer) => void, reject: (error: string | Error) => void) => {\r\n            ocsp.utils.getAuthorityInfo(req.cert, ocspMethod, (error: string, uri: string): void => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                const parsedUri: {[k: string]: any} = parse.default(uri);\r\n                parsedUri.path = parsedUri.pathname;\r\n                options = { ...options, ...parsedUri };\r\n\r\n                ocsp.utils.getResponse(options, req.data, (error: string, raw: Buffer): void => {\r\n                    if (error) {\r\n                        reject(error);\r\n                        return;\r\n                    }\r\n\r\n                    this.onEvent(new OCSPResponseRetrievedEvent(req.certID.toString(\"hex\")));\r\n                    resolve(raw);\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    private static onEvent = (event: OCSPEvent): void => {\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private CreateConnection(request: Agent.ClientRequest, options: Agent.RequestOptions): Promise<net.Socket> {\r\n        const enableOCSP: boolean = (typeof process !== \"undefined\" && process.env.NODE_TLS_REJECT_UNAUTHORIZED !== \"0\" && process.env.SPEECH_CONDUCT_OCSP_CHECK !== \"0\") && options.secureEndpoint;\r\n        let socketPromise: Promise<net.Socket>;\r\n\r\n        options = {\r\n            ...options,\r\n            ...{\r\n                requestOCSP: !CertCheckAgent.forceDisableOCSPStapling,\r\n                servername: options.host\r\n            }\r\n        };\r\n\r\n        if (!!this.privProxyInfo) {\r\n            const httpProxyAgent: HttpsProxyAgent = CertCheckAgent.GetProxyAgent(this.privProxyInfo);\r\n            const baseAgent: Agent.Agent = httpProxyAgent as unknown as Agent.Agent;\r\n\r\n            socketPromise = new Promise<net.Socket>((resolve: (value: net.Socket) => void, reject: (error: string | Error) => void) => {\r\n                baseAgent.callback(request, options, (error: Error, socket: net.Socket) => {\r\n                    if (!!error) {\r\n                        reject(error);\r\n                    } else {\r\n                        resolve(socket);\r\n                    }\r\n                });\r\n            });\r\n        } else {\r\n            if (!!options.secureEndpoint) {\r\n                socketPromise = Promise.resolve(tls.connect(options));\r\n            } else {\r\n                socketPromise = Promise.resolve(net.connect(options));\r\n            }\r\n        }\r\n\r\n        if (!!enableOCSP) {\r\n            return CertCheckAgent.OCSPCheck(socketPromise, this.privProxyInfo);\r\n        } else {\r\n            return socketPromise;\r\n        }\r\n    }\r\n}\r\n"]}