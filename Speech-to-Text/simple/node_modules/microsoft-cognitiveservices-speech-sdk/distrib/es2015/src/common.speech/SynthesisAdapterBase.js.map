{"version":3,"sources":["src/common.speech/SynthesisAdapterBase.ts"],"names":[],"mappings":"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","file":"SynthesisAdapterBase.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ArgumentNullError,\r\n    ConnectionClosedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    EventSource,\r\n    IAudioDestination,\r\n    IConnection,\r\n    IDisposable,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SpeechSynthesisBookmarkEventArgs,\r\n    SpeechSynthesisEventArgs,\r\n    SpeechSynthesisResult,\r\n    SpeechSynthesisVisemeEventArgs,\r\n    SpeechSynthesisWordBoundaryEventArgs,\r\n    SpeechSynthesizer,\r\n} from \"../sdk/Exports\";\r\nimport {\r\n    AgentConfig,\r\n    CancellationErrorCodePropertyName,\r\n    ISynthesisConnectionFactory,\r\n    MetadataType,\r\n    SynthesisAudioMetadata,\r\n    SynthesisContext,\r\n    SynthesisTurn,\r\n    SynthesizerConfig\r\n} from \"./Exports\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class SynthesisAdapterBase implements IDisposable {\r\n    protected privSynthesisTurn: SynthesisTurn;\r\n    protected privConnectionId: string;\r\n    protected privSynthesizerConfig: SynthesizerConfig;\r\n    protected privSpeechSynthesizer: SpeechSynthesizer;\r\n    protected privSuccessCallback: (e: SpeechSynthesisResult) => void;\r\n    protected privErrorCallback: (e: string) => void;\r\n\r\n    public get synthesisContext(): SynthesisContext {\r\n        return this.privSynthesisContext;\r\n    }\r\n\r\n    public get agentConfig(): AgentConfig {\r\n        return this.privAgentConfig;\r\n    }\r\n\r\n    public get connectionEvents(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    public get serviceEvents(): EventSource<ServiceEvent> {\r\n        return this.privServiceEvents;\r\n    }\r\n\r\n    protected speakOverride: (ssml: string, requestId: string, sc: (e: SpeechSynthesisResult) => void, ec: (e: string) => void) => any = undefined;\r\n\r\n    // Called when telemetry data is sent to the service.\r\n    // Used for testing Telemetry capture.\r\n    public static telemetryData: (json: string) => void;\r\n    public static telemetryDataEnabled: boolean = true;\r\n\r\n    public set activityTemplate(messagePayload: string) { this.privActivityTemplate = messagePayload; }\r\n    public get activityTemplate(): string { return this.privActivityTemplate; }\r\n\r\n    protected receiveMessageOverride: () => any = undefined;\r\n\r\n    protected connectImplOverride: (isUnAuthorized: boolean) => any = undefined;\r\n\r\n    protected configConnectionOverride: (connection: IConnection) => any = undefined;\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n        this.privSynthesisTurn.audioOutputFormat = format;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.format = format;\r\n        }\r\n        if (this.synthesisContext !== undefined) {\r\n            this.synthesisContext.audioOutputFormat = format;\r\n        }\r\n    }\r\n    private privAuthentication: IAuthentication;\r\n    private privConnectionFactory: ISynthesisConnectionFactory;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionConfigurationPromise: Promise<IConnection>;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionPromise: Promise<IConnection>;\r\n    private privAuthFetchEventId: string;\r\n    private privIsDisposed: boolean;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privServiceEvents: EventSource<ServiceEvent>;\r\n    private privSynthesisContext: SynthesisContext;\r\n    private privAgentConfig: AgentConfig;\r\n    private privServiceHasSentMessage: boolean;\r\n    private privActivityTemplate: string;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privSessionAudioDestination: IAudioDestination;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: ISynthesisConnectionFactory,\r\n        synthesizerConfig: SynthesizerConfig,\r\n        speechSynthesizer: SpeechSynthesizer,\r\n        audioDestination: IAudioDestination) {\r\n\r\n        if (!authentication) {\r\n            throw new ArgumentNullError(\"authentication\");\r\n        }\r\n\r\n        if (!connectionFactory) {\r\n            throw new ArgumentNullError(\"connectionFactory\");\r\n        }\r\n\r\n        if (!synthesizerConfig) {\r\n            throw new ArgumentNullError(\"synthesizerConfig\");\r\n        }\r\n\r\n        this.privAuthentication = authentication;\r\n        this.privConnectionFactory = connectionFactory;\r\n        this.privSynthesizerConfig = synthesizerConfig;\r\n        this.privIsDisposed = false;\r\n        this.privSpeechSynthesizer = speechSynthesizer;\r\n        this.privSessionAudioDestination = audioDestination;\r\n        this.privSynthesisTurn = new SynthesisTurn();\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privServiceEvents = new EventSource<ServiceEvent>();\r\n        this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\r\n        this.privAgentConfig = new AgentConfig();\r\n\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\r\n                if (connectionClosedEvent.statusCode !== 1000) {\r\n                    this.cancelSynthesisLocal(CancellationReason.Error,\r\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\r\n                        connectionClosedEvent.reason + \" websocket error code: \" + connectionClosedEvent.statusCode);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public static addHeader(audio: ArrayBuffer, format: AudioOutputFormatImpl): ArrayBuffer {\r\n        if (!format.hasHeader) {\r\n            return audio;\r\n        }\r\n        format.updateHeader(audio.byteLength);\r\n        const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\r\n        tmp.set(new Uint8Array(format.header), 0);\r\n        tmp.set(new Uint8Array(audio), format.header.byteLength);\r\n        return tmp.buffer;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privIsDisposed = true;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.close();\r\n        }\r\n        if (this.privConnectionConfigurationPromise) {\r\n            const connection: IConnection = await this.privConnectionConfigurationPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n    }\r\n\r\n    public async connect(): Promise<void> {\r\n        await this.connectImpl();\r\n    }\r\n\r\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\r\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\r\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\r\n    }\r\n\r\n    public async Speak(\r\n        text: string,\r\n        isSSML: boolean,\r\n        requestId: string,\r\n        successCallback: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack: (e: string) => void,\r\n        audioDestination: IAudioDestination,\r\n    ): Promise<void> {\r\n\r\n        let ssml: string;\r\n\r\n        if (isSSML) {\r\n            ssml = text;\r\n        } else {\r\n            ssml = this.privSpeechSynthesizer.buildSsml(text);\r\n        }\r\n\r\n        if (this.speakOverride !== undefined) {\r\n            return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\r\n        }\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallBack;\r\n\r\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\r\n\r\n        try {\r\n            await this.connectImpl();\r\n            const connection: IConnection = await this.fetchConnection();\r\n            await this.sendSynthesisContext(connection);\r\n            await this.sendSsmlMessage(connection, ssml, requestId);\r\n            const synthesisStartEventArgs: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                new SpeechSynthesisResult(\r\n                    requestId,\r\n                    ResultReason.SynthesizingAudioStarted,\r\n                )\r\n            );\r\n\r\n            if (!!this.privSpeechSynthesizer.synthesisStarted) {\r\n                this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\r\n            }\r\n\r\n            const messageRetrievalPromise = this.receiveMessage();\r\n        } catch (e) {\r\n            this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesis(\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n        const result: SpeechSynthesisResult = new SpeechSynthesisResult(\r\n            requestId,\r\n            ResultReason.Canceled,\r\n            undefined,\r\n            error,\r\n            properties\r\n        );\r\n\r\n        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\r\n            const cancelEvent: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(result);\r\n            try {\r\n                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n        }\r\n\r\n        if (!!this.privSuccessCallback) {\r\n            try {\r\n                this.privSuccessCallback(result);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesisLocal(\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        if (!!this.privSynthesisTurn.isSynthesizing) {\r\n            this.privSynthesisTurn.onStopSynthesizing();\r\n\r\n            this.cancelSynthesis(\r\n                this.privSynthesisTurn.requestId,\r\n                cancellationReason,\r\n                errorCode,\r\n                error);\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(\r\n        connectionMessage: SpeechConnectionMessage,\r\n        successCallback?: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack?: (e: string) => void): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected async receiveMessage(): Promise<void> {\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConnectionMessage = await connection.read();\r\n\r\n            if (this.receiveMessageOverride !== undefined) {\r\n                return this.receiveMessageOverride();\r\n            }\r\n            if (this.privIsDisposed) {\r\n                // We're done.\r\n                return;\r\n            }\r\n\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!message) {\r\n                if (!this.privSynthesisTurn.isSynthesizing) {\r\n                    return;\r\n                } else {\r\n                    return this.receiveMessage();\r\n                }\r\n            }\r\n\r\n            this.privServiceHasSentMessage = true;\r\n\r\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n            if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        this.privSynthesisTurn.onServiceTurnStartResponse();\r\n                        break;\r\n                    case \"response\":\r\n                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\r\n                        break;\r\n                    case \"audio\":\r\n                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\r\n                            && !!connectionMessage.binaryBody) {\r\n                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\r\n                            if (!!this.privSpeechSynthesizer.synthesizing) {\r\n                                try {\r\n                                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\r\n                                    const ev: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                                        new SpeechSynthesisResult(\r\n                                            this.privSynthesisTurn.requestId,\r\n                                            ResultReason.SynthesizingAudio,\r\n                                            audioWithHeader));\r\n                                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\r\n                                } catch (error) {\r\n                                    // Not going to let errors in the event handler\r\n                                    // trip things up.\r\n                                }\r\n                            }\r\n                            if (this.privSessionAudioDestination !== undefined) {\r\n                                this.privSessionAudioDestination.write(connectionMessage.binaryBody);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"audio.metadata\":\r\n                        const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\r\n                        for (const metadata of metadataList) {\r\n                            switch (metadata.Type) {\r\n                                case MetadataType.WordBoundary:\r\n                                    this.privSynthesisTurn.onWordBoundaryEvent(metadata.Data.text.Text);\r\n\r\n                                    const wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.text.Text,\r\n                                        metadata.Data.text.Length,\r\n                                        this.privSynthesisTurn.currentTextOffset);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.wordBoundary) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Bookmark:\r\n                                    const bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Bookmark);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Viseme:\r\n\r\n                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\r\n\r\n                                    if (metadata.Data.IsLastAnimation) {\r\n                                        const visemeEventArgs: SpeechSynthesisVisemeEventArgs = new SpeechSynthesisVisemeEventArgs(\r\n                                            metadata.Data.Offset,\r\n                                            metadata.Data.VisemeId,\r\n                                            this.privSynthesisTurn.getAndClearVisemeAnimation());\r\n\r\n                                        if (!!this.privSpeechSynthesizer.visemeReceived) {\r\n                                            try {\r\n                                                this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\r\n                                            } catch (error) {\r\n                                                // Not going to let errors in the event handler\r\n                                                // trip things up.\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"turn.end\":\r\n                        this.privSynthesisTurn.onServiceTurnEndResponse();\r\n                        let result: SpeechSynthesisResult;\r\n                        try {\r\n                            const audioBuffer: ArrayBuffer = await this.privSynthesisTurn.getAllReceivedAudioWithHeader();\r\n                            result = new SpeechSynthesisResult(\r\n                                this.privSynthesisTurn.requestId,\r\n                                ResultReason.SynthesizingAudioCompleted,\r\n                                audioBuffer\r\n                            );\r\n                            if (!!this.privSuccessCallback) {\r\n                                this.privSuccessCallback(result);\r\n                            }\r\n                        } catch (error) {\r\n                            if (!!this.privErrorCallback) {\r\n                                this.privErrorCallback(error);\r\n                            }\r\n                        }\r\n                        if (this.privSpeechSynthesizer.synthesisCompleted) {\r\n                            try {\r\n                                this.privSpeechSynthesizer.synthesisCompleted(\r\n                                    this.privSpeechSynthesizer,\r\n                                    new SpeechSynthesisEventArgs(result)\r\n                                );\r\n                            } catch (e) {\r\n                                // Not going to let errors in the event handler\r\n                                // trip things up.\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\r\n                            if (!!this.privServiceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n\r\n                }\r\n            }\r\n\r\n            return this.receiveMessage();\r\n\r\n        } catch (e) {\r\n            // TODO: What goes here?\r\n        }\r\n    }\r\n\r\n    protected sendSynthesisContext = (connection: IConnection): Promise<void> => {\r\n        const synthesisContextJson = this.synthesisContext.toJSON();\r\n\r\n        if (synthesisContextJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"synthesis.context\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                synthesisContextJson));\r\n        }\r\n        return;\r\n    }\r\n\r\n    protected connectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n        if (this.privConnectionPromise) {\r\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionPromise = null;\r\n                    this.privServiceHasSentMessage = false;\r\n                    return this.connectImpl();\r\n                }\r\n                return this.privConnectionPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionPromise = null;\r\n                this.privServiceHasSentMessage = false;\r\n                return this.connectImpl();\r\n            });\r\n        }\r\n        this.privAuthFetchEventId = createNoDashGuid();\r\n        this.privConnectionId = createNoDashGuid();\r\n\r\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\r\n\r\n        this.privConnectionPromise = authPromise.then(async (result: AuthInfo) => {\r\n            await this.privSynthesisTurn.onAuthCompleted(false);\r\n\r\n            const connection: IConnection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\r\n\r\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n            // it'll stop sending events.\r\n            connection.events.attach((event: ConnectionEvent) => {\r\n                this.connectionEvents.onEvent(event);\r\n            });\r\n            const response = await connection.open();\r\n            if (response.statusCode === 200) {\r\n                await this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.resolve(connection);\r\n            } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                return this.connectImpl(true);\r\n            } else {\r\n                await this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n            }\r\n        }, async (error: string): Promise<IConnection> => {\r\n            await this.privSynthesisTurn.onAuthCompleted(true, error);\r\n            throw new Error(error);\r\n        });\r\n\r\n        // Attach an empty handler to allow the promise to run in the background while\r\n        // other startup events happen. It'll eventually be awaited on.\r\n        this.privConnectionPromise.catch(() => { });\r\n\r\n        return this.privConnectionPromise;\r\n    }\r\n    protected sendSpeechServiceConfig = (connection: IConnection, SpeechServiceConfigJson: string): Promise<void> => {\r\n        if (SpeechServiceConfigJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"speech.config\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                SpeechServiceConfigJson));\r\n        }\r\n    }\r\n\r\n    protected sendSsmlMessage = (connection: IConnection, ssml: string, requestId: string): Promise<void> => {\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"ssml\",\r\n            requestId,\r\n            \"application/ssml+xml\",\r\n            ssml));\r\n    }\r\n\r\n    private async fetchConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigurationPromise) {\r\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigurationPromise = null;\r\n                    this.privServiceHasSentMessage = false;\r\n                    return this.fetchConnection();\r\n                }\r\n                return this.privConnectionConfigurationPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigurationPromise = null;\r\n                this.privServiceHasSentMessage = false;\r\n                return this.fetchConnection();\r\n            });\r\n        }\r\n        this.privConnectionConfigurationPromise = this.configureConnection();\r\n        return await this.privConnectionConfigurationPromise;\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configureConnection(): Promise<IConnection> {\r\n        const connection: IConnection = await this.connectImpl();\r\n        if (this.configConnectionOverride !== undefined) {\r\n            return this.configConnectionOverride(connection);\r\n        }\r\n        await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\r\n        return connection;\r\n    }\r\n}\r\n"]}