{"version":3,"sources":["src/common.speech/DialogServiceAdapter.ts"],"names":[],"mappings":"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","file":"DialogServiceAdapter.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ReplayableAudioNode\r\n} from \"../common.browser/Exports\";\r\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\r\nimport {\r\n    BackgroundEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    createGuid,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    DialogEvent,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    ActivityReceivedEventArgs,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    DialogServiceConfig,\r\n    DialogServiceConnector,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    RecognitionEventArgs,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n    SpeechRecognitionCanceledEventArgs,\r\n    SpeechRecognitionEventArgs,\r\n    SpeechRecognitionResult,\r\n    TurnStatusReceivedEventArgs,\r\n} from \"../sdk/Exports\";\r\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\r\nimport {\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionStatus,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechDetected,\r\n    SpeechHypothesis,\r\n} from \"./Exports\";\r\nimport { IAuthentication } from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport { RecognitionMode, RecognizerConfig } from \"./RecognizerConfig\";\r\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\r\n    private privDialogServiceConnector: DialogServiceConnector;\r\n\r\n    private privDialogAudioSource: IAudioSource;\r\n\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private agentConfigSent: boolean;\r\n    private privLastResult: SpeechRecognitionResult;\r\n    private privEvents: EventSource<DialogEvent>;\r\n\r\n    // Turns are of two kinds:\r\n    // 1: SR turns, end when the SR result is returned and then turn end.\r\n    // 2: Service turns where an activity is sent by the service along with the audio.\r\n    private privTurnStateManager: DialogServiceTurnStateManager;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        dialogServiceConnector: DialogServiceConnector) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\r\n\r\n        this.privEvents = new EventSource<DialogEvent>();\r\n        this.privDialogServiceConnector = dialogServiceConnector;\r\n        this.receiveMessageOverride = this.receiveDialogMessageOverride;\r\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\r\n        this.recognizeOverride = this.listenOnce;\r\n        this.postConnectImplOverride = this.dialogConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privDialogAudioSource = audioSource;\r\n\r\n        this.agentConfigSent = false;\r\n        this.privLastResult = null;\r\n        this.connectionEvents.attach(async (connectionEvent: ConnectionEvent): Promise<void> => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                this.terminateMessageLoop = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const interactionGuid: string = createGuid();\r\n        const requestId: string = createNoDashGuid();\r\n\r\n        const agentMessage: any = {\r\n            context: {\r\n                interactionId: interactionGuid\r\n            },\r\n            messagePayload: JSON.parse(message),\r\n            version: 0.5\r\n        };\r\n\r\n        const agentMessageJson = JSON.stringify(agentMessage);\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"agent\",\r\n            requestId,\r\n            \"application/json\",\r\n            agentMessageJson));\r\n\r\n    }\r\n\r\n    protected async privDisconnect(): Promise<void> {\r\n        await this.cancelRecognition(this.privRequestSession.sessionId,\r\n            this.privRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        this.agentConfigSent = false;\r\n        return;\r\n    }\r\n\r\n    protected async processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        let result: SpeechRecognitionResult;\r\n        let processed: boolean;\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.phrase\":\r\n                const speechPhrase: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n\r\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\r\n\r\n                if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\r\n                    const args: SpeechRecognitionEventArgs = this.fireEventForResult(speechPhrase, resultProps);\r\n                    this.privLastResult = args.result;\r\n\r\n                    if (!!this.privDialogServiceConnector.recognized) {\r\n                        try {\r\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\r\n                            /* tslint:disable:no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.hypothesis\":\r\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    ResultReason.RecognizingSpeech,\r\n                    hypothesis.Text,\r\n                    hypothesis.Duration,\r\n                    offset,\r\n                    hypothesis.Language,\r\n                    hypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privRequestSession.onHypothesis(offset);\r\n\r\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognizing) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"audio\":\r\n                {\r\n                    const audioRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const turn = this.privTurnStateManager.GetTurn(audioRequestId);\r\n                    try {\r\n                        // Empty binary message signals end of stream.\r\n                        if (!connectionMessage.binaryBody) {\r\n                            turn.endAudioStream();\r\n                        } else {\r\n                            turn.audioStream.write(connectionMessage.binaryBody);\r\n                        }\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"response\":\r\n                {\r\n                    this.handleResponseMessage(connectionMessage);\r\n\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        return processed;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected async cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): Promise<void> {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        if (!!this.privRequestSession.isRecognizing) {\r\n            await this.privRequestSession.onStopRecognizing();\r\n        }\r\n\r\n        if (!!this.privDialogServiceConnector.canceled) {\r\n            const properties: PropertyCollection = new PropertyCollection();\r\n            properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                sessionId);\r\n\r\n            try {\r\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n\r\n            if (!!this.privSuccessCallback) {\r\n                const result: SpeechRecognitionResult = new SpeechRecognitionResult(\r\n                    undefined, // ResultId\r\n                    ResultReason.Canceled,\r\n                    undefined, // Text\r\n                    undefined, // Duration\r\n                    undefined, // Offset\r\n                    undefined, // Language\r\n                    undefined, // Language Detection Confidence\r\n                    undefined, // Speaker Id\r\n                    error,\r\n                    undefined, // Json\r\n                    properties);\r\n                try {\r\n                    this.privSuccessCallback(result);\r\n                    this.privSuccessCallback = undefined;\r\n                    /* tslint:disable:no-empty */\r\n                } catch { }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async listenOnce(\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallback: (e: string) => void\r\n    ): Promise<void> {\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallback;\r\n\r\n        this.privRequestSession.startNewRecognition();\r\n        this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\r\n\r\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        const conPromise: Promise<IConnection> = this.connectImpl();\r\n\r\n        const preAudioPromise: Promise<void> = this.sendPreAudioMessages();\r\n\r\n        const node: IAudioStreamNode = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\r\n        const format: AudioStreamFormatImpl = await this.privDialogAudioSource.format;\r\n        const deviceInfo: ISpeechConfigAudioDevice = await this.privDialogAudioSource.deviceInfo;\r\n\r\n        const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\r\n        await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n        try {\r\n            await conPromise;\r\n            await preAudioPromise;\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n\r\n        if (!!this.privRecognizer.sessionStarted) {\r\n            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n        }\r\n\r\n        const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n        // /* tslint:disable:no-empty */\r\n        audioSendPromise.then(() => { /*add? return true;*/ }, async (error: string) => {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n    }\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    private dialogConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    private receiveDialogMessageOverride(): Promise<void> {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        const loop = async (): Promise<void> => {\r\n            try {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return;\r\n                }\r\n\r\n                const connection: IConnection = await this.fetchConnection();\r\n                const message: ConnectionMessage = await connection.read();\r\n\r\n                if (!message) {\r\n                    return loop();\r\n                }\r\n\r\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        {\r\n                            const turnRequestId = connectionMessage.requestId.toUpperCase();\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.StartTurn(turnRequestId);\r\n                            } else {\r\n                                this.privRequestSession.onServiceTurnStartResponse();\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case \"speech.startdetected\":\r\n                        const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n\r\n                        const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechStartDetected) {\r\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case \"speech.enddetected\":\r\n\r\n                        let json: string;\r\n\r\n                        if (connectionMessage.textBody.length > 0) {\r\n                            json = connectionMessage.textBody;\r\n                        } else {\r\n                            // If the request was empty, the JSON returned is empty.\r\n                            json = \"{ Offset: 0 }\";\r\n                        }\r\n\r\n                        const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n\r\n                        this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\r\n\r\n                        const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechEndDetected) {\r\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                        }\r\n                        break;\r\n\r\n                    case \"turn.end\":\r\n                        {\r\n                            const turnEndRequestId = connectionMessage.requestId.toUpperCase();\r\n\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnEndRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\r\n                            } else {\r\n                                // Audio session turn\r\n\r\n                                const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n                                await this.privRequestSession.onServiceTurnEndResponse(false);\r\n\r\n                                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\r\n                                    if (!!this.privRecognizer.sessionStopped) {\r\n                                        this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                                    }\r\n                                }\r\n\r\n                                // report result to promise.\r\n                                if (!!this.privSuccessCallback && this.privLastResult) {\r\n                                    try {\r\n                                        this.privSuccessCallback(this.privLastResult);\r\n                                        this.privLastResult = null;\r\n                                    } catch (e) {\r\n                                        if (!!this.privErrorCallback) {\r\n                                            this.privErrorCallback(e);\r\n                                        }\r\n                                    }\r\n                                    // Only invoke the call back once.\r\n                                    // and if it's successful don't invoke the\r\n                                    // error after that.\r\n                                    this.privSuccessCallback = undefined;\r\n                                    this.privErrorCallback = undefined;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            if (!!this.serviceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n                }\r\n                const ret: Promise<void> = loop();\r\n\r\n                return ret;\r\n            } catch (error) {\r\n                this.terminateMessageLoop = true;\r\n                communicationCustodian.resolve();\r\n            }\r\n        };\r\n\r\n        loop().catch((reason: string): void => {\r\n            Events.instance.onEvent(new BackgroundEvent(reason));\r\n        });\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        try {\r\n            await this.receiveDialogMessageOverride();\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configConnection(connection: IConnection): Promise<IConnection> {\r\n        if (this.terminateMessageLoop) {\r\n            this.terminateMessageLoop = false;\r\n            return Promise.reject(`Connection to service terminated.`);\r\n        }\r\n\r\n        await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\r\n        await this.sendAgentConfig(connection);\r\n        return connection;\r\n    }\r\n\r\n    private async sendPreAudioMessages(): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await this.sendAgentContext(connection);\r\n        await this.sendWaveHeader(connection);\r\n    }\r\n\r\n    private sendAgentConfig = (connection: IConnection): Promise<void> => {\r\n        if (this.agentConfig && !this.agentConfigSent) {\r\n\r\n            if (this.privRecognizerConfig\r\n                .parameters\r\n                .getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\r\n                const config = this.agentConfig.get();\r\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\r\n                this.agentConfig.set(config);\r\n            }\r\n            this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\r\n\r\n            const agentConfigJson = this.agentConfig.toJsonString();\r\n\r\n            // guard against sending this multiple times on one connection\r\n            this.agentConfigSent = true;\r\n\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent.config\",\r\n                this.privRequestSession.requestId,\r\n                \"application/json\",\r\n                agentConfigJson));\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    private sendAgentContext = (connection: IConnection): Promise<void> => {\r\n        const guid: string = createGuid();\r\n\r\n        const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\r\n\r\n        const agentContext: any = {\r\n            channelData: \"\",\r\n            context: {\r\n                interactionId: guid\r\n            },\r\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\r\n            version: 0.5\r\n        };\r\n\r\n        const agentContextJson = JSON.stringify(agentContext);\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speech.agent.context\",\r\n            this.privRequestSession.requestId,\r\n            \"application/json\",\r\n            agentContextJson));\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: SimpleSpeechPhrase, properties: PropertyCollection): SpeechRecognitionEventArgs {\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\r\n\r\n        const offset: number = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.DisplayText,\r\n            serviceResult.Duration,\r\n            offset,\r\n            serviceResult.Language,\r\n            serviceResult.LanguageDetectionConfidence,\r\n            undefined,\r\n            undefined,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n\r\n    private handleResponseMessage = (responseMessage: SpeechConnectionMessage): void => {\r\n        // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\r\n        // event according to the message type that's specified.\r\n        const responsePayload = JSON.parse(responseMessage.textBody);\r\n        switch (responsePayload.messageType.toLowerCase()) {\r\n            case \"message\":\r\n                const responseRequestId = responseMessage.requestId.toUpperCase();\r\n                const activityPayload: ActivityPayloadResponse = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\r\n                const turn = this.privTurnStateManager.GetTurn(responseRequestId);\r\n\r\n                // update the conversation Id\r\n                if (activityPayload.conversationId) {\r\n                    const updateAgentConfig = this.agentConfig.get();\r\n                    updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\r\n                    this.agentConfig.set(updateAgentConfig);\r\n                }\r\n\r\n                const pullAudioOutputStream: PullAudioOutputStreamImpl = turn.processActivityPayload(\r\n                    activityPayload,\r\n                    AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\r\n                const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\r\n                if (!!this.privDialogServiceConnector.activityReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"messagestatus\":\r\n                if (!!this.privDialogServiceConnector.turnStatusReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.turnStatusReceived(\r\n                            this.privDialogServiceConnector,\r\n                            new TurnStatusReceivedEventArgs(responseMessage.textBody));\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            default:\r\n                Events.instance.onEvent(\r\n                    new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onEvent(event: DialogEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n}\r\n"]}