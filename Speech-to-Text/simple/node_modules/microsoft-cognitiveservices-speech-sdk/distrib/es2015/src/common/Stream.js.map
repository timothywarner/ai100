{"version":3,"sources":["src/common/Stream.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC;;;;;;;;;;AAElC,OAAO,EAAE,qBAAqB,EAAE,MAAM,SAAS,CAAC;AAChD,OAAO,EAAE,gBAAgB,EAAE,MAAM,QAAQ,CAAC;AAC1C,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAQhC,MAAM,OAAO,MAAM;IAMf,YAAmB,QAAiB;QAJ5B,qBAAgB,GAAY,KAAK,CAAC;QAClC,oBAAe,GAAY,KAAK,CAAC;QA0ClC,SAAI,GAAG,GAAmC,EAAE;YAC/C,IAAI,IAAI,CAAC,eAAe,EAAE;gBACtB,MAAM,IAAI,qBAAqB,CAAC,kCAAkC,CAAC,CAAC;aACvE;YAED,OAAO,IAAI,CAAC,eAAe;iBACtB,OAAO,EAAE;iBACT,IAAI,CAAC,CAAO,WAAkC,EAAE,EAAE;gBAC/C,IAAI,WAAW,KAAK,SAAS,IAAI,WAAW,CAAC,KAAK,EAAE;oBAChD,MAAM,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,uBAAuB,CAAC,CAAC;iBAC/D;gBAED,OAAO,WAAW,CAAC;YACvB,CAAC,CAAA,CAAC,CAAC;QACX,CAAC,CAAA;QACM,cAAS,GAAG,GAAS,EAAE;YAC1B,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;gBACvB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;gBAC5B,IAAI,CAAC,eAAe,GAAG,IAAI,KAAK,EAAyB,CAAC;aAC7D;QACL,CAAC,CAAA;QAEO,kBAAa,GAAG,GAAS,EAAE;YAC/B,IAAI,IAAI,CAAC,gBAAgB,EAAE;gBACvB,MAAM,IAAI,qBAAqB,CAAC,eAAe,CAAC,CAAC;aACpD;QACL,CAAC,CAAA;QAhEG,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,gBAAgB,EAAE,CAAC;QACvD,IAAI,CAAC,eAAe,GAAG,IAAI,KAAK,EAAyB,CAAC;IAC9D,CAAC;IAED,IAAW,QAAQ;QACf,OAAO,IAAI,CAAC,gBAAgB,CAAC;IACjC,CAAC;IAED,IAAW,WAAW;QAClB,OAAO,IAAI,CAAC,eAAe,CAAC;IAChC,CAAC;IAED,IAAW,EAAE;QACT,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAEM,KAAK;QACR,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;YACxB,IAAI,CAAC,gBAAgB,CAAC;gBAClB,MAAM,EAAE,IAAI;gBACZ,KAAK,EAAE,IAAI;gBACX,YAAY,EAAE,IAAI,CAAC,GAAG,EAAE;aAC3B,CAAC,CAAC;YACH,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;SAChC;IACL,CAAC;IAEM,gBAAgB,CAAC,WAAkC;QACtD,IAAI,CAAC,aAAa,EAAE,CAAC;QACrB,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,EAAE;YACpC,IAAI;gBACA,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;aAC7C;YAAC,OAAO,CAAC,EAAE;gBACR,aAAa;aAChB;SACJ;IACL,CAAC;CA6BJ","file":"Stream.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"./Error\";\r\nimport { createNoDashGuid } from \"./Guid\";\r\nimport { Queue } from \"./Queue\";\r\n\r\nexport interface IStreamChunk<TBuffer> {\r\n    isEnd: boolean;\r\n    buffer: TBuffer;\r\n    timeReceived: number;\r\n}\r\n\r\nexport class Stream<TBuffer> {\r\n    private privId: string;\r\n    private privIsWriteEnded: boolean = false;\r\n    private privIsReadEnded: boolean = false;\r\n    private privReaderQueue: Queue<IStreamChunk<TBuffer>>;\r\n\r\n    public constructor(streamId?: string) {\r\n        this.privId = streamId ? streamId : createNoDashGuid();\r\n        this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsWriteEnded;\r\n    }\r\n\r\n    public get isReadEnded(): boolean {\r\n        return this.privIsReadEnded;\r\n    }\r\n\r\n    public get id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public close(): void {\r\n        if (!this.privIsWriteEnded) {\r\n            this.writeStreamChunk({\r\n                buffer: null,\r\n                isEnd: true,\r\n                timeReceived: Date.now(),\r\n            });\r\n            this.privIsWriteEnded = true;\r\n        }\r\n    }\r\n\r\n    public writeStreamChunk(streamChunk: IStreamChunk<TBuffer>): void {\r\n        this.throwIfClosed();\r\n        if (!this.privReaderQueue.isDisposed()) {\r\n            try {\r\n                this.privReaderQueue.enqueue(streamChunk);\r\n            } catch (e) {\r\n                // Do nothing\r\n            }\r\n        }\r\n    }\r\n\r\n    public read = (): Promise<IStreamChunk<TBuffer>> => {\r\n        if (this.privIsReadEnded) {\r\n            throw new InvalidOperationError(\"Stream read has already finished\");\r\n        }\r\n\r\n        return this.privReaderQueue\r\n            .dequeue()\r\n            .then(async (streamChunk: IStreamChunk<TBuffer>) => {\r\n                if (streamChunk === undefined || streamChunk.isEnd) {\r\n                    await this.privReaderQueue.dispose(\"End of stream reached\");\r\n                }\r\n\r\n                return streamChunk;\r\n            });\r\n    }\r\n    public readEnded = (): void => {\r\n        if (!this.privIsReadEnded) {\r\n            this.privIsReadEnded = true;\r\n            this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\r\n        }\r\n    }\r\n\r\n    private throwIfClosed = (): void => {\r\n        if (this.privIsWriteEnded) {\r\n            throw new InvalidOperationError(\"Stream closed\");\r\n        }\r\n    }\r\n}\r\n"]}