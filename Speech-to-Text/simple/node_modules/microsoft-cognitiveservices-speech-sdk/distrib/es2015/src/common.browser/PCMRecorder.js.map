{"version":3,"sources":["src/common.browser/PCMRecorder.ts"],"names":[],"mappings":"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","file":"PCMRecorder.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { RiffPcmEncoder, Stream } from \"../common/Exports\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\nexport class PcmRecorder implements IRecorder {\r\n    private privMediaResources: IMediaResources;\r\n    private privSpeechProcessorScript: string; // speech-processor.js Url\r\n\r\n    public record = (context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void => {\r\n        const desiredSampleRate = 16000;\r\n\r\n        const scriptNode = (() => {\r\n            let bufferSize = 0;\r\n            try {\r\n                return context.createScriptProcessor(bufferSize, 1, 1);\r\n            } catch (error) {\r\n                // Webkit (<= version 31) requires a valid bufferSize.\r\n                bufferSize = 2048;\r\n                let audioSampleRate = context.sampleRate;\r\n                while (bufferSize < 16384 && audioSampleRate >= (2 * desiredSampleRate)) {\r\n                    bufferSize <<= 1;\r\n                    audioSampleRate >>= 1;\r\n                }\r\n                return context.createScriptProcessor(bufferSize, 1, 1);\r\n            }\r\n        })();\r\n\r\n        const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\r\n        let needHeader: boolean = true;\r\n        const that = this;\r\n        scriptNode.onaudioprocess = (event: AudioProcessingEvent) => {\r\n            const inputFrame = event.inputBuffer.getChannelData(0);\r\n\r\n            if (outputStream && !outputStream.isClosed) {\r\n                const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                if (!!waveFrame) {\r\n                    outputStream.writeStreamChunk({\r\n                        buffer: waveFrame,\r\n                        isEnd: false,\r\n                        timeReceived: Date.now(),\r\n                    });\r\n                    needHeader = false;\r\n                }\r\n            }\r\n        };\r\n\r\n        const micInput = context.createMediaStreamSource(mediaStream);\r\n\r\n        // https://webaudio.github.io/web-audio-api/#audioworklet\r\n        // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\r\n\r\n        if (!!this.privSpeechProcessorScript && !!context.audioWorklet) {\r\n            context.audioWorklet\r\n                .addModule(this.privSpeechProcessorScript)\r\n                .then(() => {\r\n                    const workletNode = new AudioWorkletNode(context, \"speech-processor\");\r\n                    workletNode.port.onmessage = (ev: MessageEvent) => {\r\n                        const inputFrame: Float32Array = ev.data as Float32Array;\r\n\r\n                        if (outputStream && !outputStream.isClosed) {\r\n                            const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                            if (!!waveFrame) {\r\n                                outputStream.writeStreamChunk({\r\n                                    buffer: waveFrame,\r\n                                    isEnd: false,\r\n                                    timeReceived: Date.now(),\r\n                                });\r\n                                needHeader = false;\r\n                            }\r\n                        }\r\n                    };\r\n                    micInput.connect(workletNode);\r\n                    workletNode.connect(context.destination);\r\n                    this.privMediaResources = {\r\n                        scriptProcessorNode: workletNode,\r\n                        source: micInput,\r\n                        stream: mediaStream,\r\n                    };\r\n                })\r\n                .catch(() => {\r\n                    micInput.connect(scriptNode);\r\n                    scriptNode.connect(context.destination);\r\n                    this.privMediaResources = {\r\n                        scriptProcessorNode: scriptNode,\r\n                        source: micInput,\r\n                        stream: mediaStream,\r\n                    };\r\n                });\r\n        } else {\r\n            micInput.connect(scriptNode);\r\n            scriptNode.connect(context.destination);\r\n            this.privMediaResources = {\r\n                scriptProcessorNode: scriptNode,\r\n                source: micInput,\r\n                stream: mediaStream,\r\n            };\r\n        }\r\n    }\r\n\r\n    public releaseMediaResources = (context: AudioContext): void => {\r\n        if (this.privMediaResources) {\r\n            if (this.privMediaResources.scriptProcessorNode) {\r\n                this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\r\n                this.privMediaResources.scriptProcessorNode = null;\r\n            }\r\n            if (this.privMediaResources.source) {\r\n                this.privMediaResources.source.disconnect();\r\n                this.privMediaResources.stream.getTracks().forEach((track: any) => track.stop());\r\n                this.privMediaResources.source = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setWorkletUrl(url: string): void {\r\n        this.privSpeechProcessorScript = url;\r\n    }\r\n}\r\n\r\ninterface IMediaResources {\r\n    source: MediaStreamAudioSourceNode;\r\n    scriptProcessorNode: ScriptProcessorNode | AudioWorkletNode;\r\n    stream: MediaStream;\r\n}\r\n"]}