/**
 * @license xmlhttprequest-ts
 * MIT license
 */

import { readFile, readFileSync, writeFileSync, unlinkSync, existsSync } from 'fs';
import { request } from 'http';
import { request as request$1 } from 'https';
import { parse } from 'url';
import { tmpdir } from 'os';
import { sep } from 'path';
import { spawn } from 'child_process';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * defines the node implementaton of the XMLHttpRequest object specs
 *
 * see: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 */
class XMLHttpRequest {
    constructor() {
        /**
         * constant representing the state an XMLHttpRequest is in after being constructed
         */
        this.UNSENT = XMLHttpRequest.UNSENT;
        /**
         * constant representing the state an XMLHttpRequest is in after 'open' was called
         */
        this.OPENED = XMLHttpRequest.OPENED;
        /**
         * constant representing the state an XMLHttpRequest is in when all response headers have been received
         */
        this.HEADERS_RECEIVED = XMLHttpRequest.HEADERS_RECEIVED;
        /**
         * constant representing the state an XMLHttpRequest is in when either the data transfer has been completed or something went wrong
         */
        this.LOADING = XMLHttpRequest.LOADING;
        /**
         * constant representing the state an XMLHttpRequest is in when the response entity body is being received
         */
        this.DONE = XMLHttpRequest.DONE;
        /**
         * option to disable the builtin header blacklist
         *
         * IMPORTANT: this is not part of the XHR specs
         */
        this.disableHeaderCheck = false;
        /**
         * stores the ready state of the request (see UNSENT, OPENED, HEADERS_RECEIVED, LOADING, DONE)
         */
        this.readyState = XMLHttpRequest.UNSENT;
        /**
         * the text received from a server following a request being sent
         */
        this.responseText = '';
        /**
         * usually contains a document instance of the parsed request result but since the dom isn't available in node, this is always null
         */
        this.responseXML = null;
        /**
         * the numerical status code of the response
         */
        this.status = 0;
        /**
         * the text received from a server following a request being sent
         */
        this.statusText = '';
        /**
         * timeout in milliseconds after a request should time out
         */
        this.timeout = 0;
        /**
         * indicates whether or not cross-site Access-Control requests should be made using credentials like authorization headers
         */
        this.withCredentials = false;
        /**
         * defines the default headers sent by our requests
         */
        this.defaultHeaders = {
            'User-Agent': 'ts-XMLHttpRequest',
            'Accept': '*/*'
        };
        /**
         * error flag, used when errors occur or abort is called
         */
        this.errorFlag = false;
        /**
         * list of headers that are not setable by the user according to the specs
         *
         * IMPORTNAT: this can optionally be disabled by setting disableHeaderCheck to true
         */
        this.forbiddenRequestHeaders = [
            'accept-charset',
            'accept-encoding',
            'access-control-request-headers',
            'access-control-request-method',
            'connection',
            'content-length',
            'content-transfer-encoding',
            'cookie',
            'cookie2',
            'date',
            'expect',
            'host',
            'keep-alive',
            'origin',
            'referer',
            'te',
            'trailer',
            'transfer-encoding',
            'upgrade',
            'via'
        ];
        /**
         * list of request methods that are not setable by the user according to the specs
         */
        this.forbiddenRequestMethods = [
            'TRACE',
            'TRACK',
            'CONNECT'
        ];
        /**
         * stores the headers that are used for this request
         */
        this.headers = {};
        /**
         * stores the headers that are used for this request with the name being lower-cased
         */
        this.headersLowerCase = {};
        /**
         * stores the event listeners that have been set via the addEventListener method
         */
        this.listeners = {};
        /**
         * flag indicating if a request was sent already
         */
        this.sendFlag = false;
    }
    /**
     * Open the connection. Currently supports local server requests.
     *
     * @param {?} method Connection method (eg GET, POST)
     * @param {?} url URL for the connection.
     * @param {?=} async Asynchronous connection (optional - default is true)
     * @param {?=} user Username for basic authentication (optional)
     * @param {?=} password Password for basic authentication (optional)
     * @return {?}
     */
    open(method, url, async = true, user, password) {
        this.abort();
        this.errorFlag = false;
        // Check for valid request method
        if (!this.isAllowedHttpMethod(method)) {
            throw new Error('SecurityError: Request method not allowed');
        }
        this.settings = {
            'method': method,
            'url': url,
            'async': (typeof async !== 'boolean' ? true : async),
            'user': user,
            'password': password
        };
        this.setState(this.OPENED);
    }
    /**
     * disables or enables the check of allowed headers in the request
     *
     * IMPORTANT: this is not part of the W3C spec
     *
     * @param {?} state Enable or disable header checking.
     * @return {?}
     */
    setDisableHeaderCheck(state) {
        this.disableHeaderCheck = state;
    }
    /**
     * sets a header for the request or appends the value if one is already set
     *
     * @param {?} header header name
     * @param {?} value header value
     * @return {?}
     */
    setRequestHeader(header, value) {
        if (this.readyState !== this.OPENED) {
            throw new Error('INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN');
        }
        if (!this.isAllowedHttpHeader(header)) {
            console.warn('Refused to set unsafe header \"' + header + '\"');
            return;
        }
        if (this.sendFlag) {
            throw new Error('INVALID_STATE_ERR: send flag is true');
        }
        header = this.headersLowerCase[header.toLowerCase()] || header;
        this.headersLowerCase[header.toLowerCase()] = header;
        this.headers[header] = this.headers[header] ? this.headers[header] + ', ' + value : value;
    }
    /**
     * returns all the response headers, separated by CRLF, as a string, or null if no response has been received
     *
     * @return {?} a string with all response headers separated by CR+LF, or null if no response has been received
     */
    getAllResponseHeaders() {
        if (this.readyState < this.HEADERS_RECEIVED || this.errorFlag) {
            return null;
        }
        let /** @type {?} */ result = '';
        if (this.response) {
            for (const /** @type {?} */ i in this.response.headers) {
                // Cookie headers are excluded
                if (i !== 'set-cookie' && i !== 'set-cookie2') {
                    const /** @type {?} */ headerValue = this.response.headers[i];
                    if (typeof headerValue === 'string') {
                        result += i + ': ' + headerValue + '\r\n';
                    }
                    else if (Array.isArray(headerValue)) {
                        result += i + ': ' + headerValue.join(', ') + '\r\n';
                    }
                    else {
                        result += i + ':\r\n';
                    }
                }
            }
        }
        return result.substr(0, result.length - 2);
    }
    /**
     * gets a header from the server response.
     *
     * @param {?} header
     * @return {?} text of the header or null if it doesn't exist.
     */
    getResponseHeader(header) {
        if (typeof header === 'string' &&
            this.readyState > this.OPENED &&
            this.response &&
            this.response.headers &&
            this.response.headers[header.toLowerCase()] &&
            !this.errorFlag) {
            const /** @type {?} */ responseHeader = this.response.headers[header.toLowerCase()];
            if (typeof responseHeader === 'string') {
                return responseHeader;
            }
            if (Array.isArray(responseHeader)) {
                return responseHeader.join(', ');
            }
        }
        return null;
    }
    /**
     * gets a request header that was set in this instance
     *
     * IMPORTANT: this is not part of the W3C specs
     *
     * @param {?} name
     * @return {?} returns the request header or empty string if not set
     */
    getRequestHeader(name) {
        if (typeof name === 'string' && this.headersLowerCase[name.toLowerCase()]) {
            return this.headers[this.headersLowerCase[name.toLowerCase()]];
        }
        return undefined;
    }
    /**
     * sends the request to the server.
     *
     * @param {?=} data
     * @return {?}
     */
    send(data) {
        const /** @type {?} */ self = this;
        if (this.settings === undefined) {
            throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');
        }
        if (this.readyState !== this.OPENED) {
            throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');
        }
        if (this.sendFlag) {
            throw new Error('INVALID_STATE_ERR: send has already been called');
        }
        let /** @type {?} */ ssl = false, /** @type {?} */ local = false;
        const /** @type {?} */ url = parse(this.settings.url);
        let /** @type {?} */ host;
        // Determine the server
        switch (url.protocol) {
            case 'https:':
                ssl = true;
            // SSL & non-SSL both need host, no break here.
            case 'http:':
                host = url.hostname;
                break;
            case 'file:':
                local = true;
                break;
            case undefined:
            case null:
            case '':
                host = 'localhost';
                break;
            default:
                throw new Error('Protocol not supported.');
        }
        // Load files off the local filesystem (file://)
        if (local) {
            if (this.settings.method !== 'GET') {
                throw new Error('XMLHttpRequest: Only GET method is supported');
            }
            if (this.settings.async) {
                readFile(unescape(url.pathname || '/'), 'utf8', function (error, fileData) {
                    if (error) {
                        self.handleError(error);
                    }
                    else {
                        self.status = 200;
                        self.responseText = fileData;
                        self.setState(self.DONE);
                    }
                });
            }
            else {
                try {
                    this.responseText = readFileSync(unescape(url.pathname || '/'), 'utf8');
                    this.status = 200;
                    this.setState(self.DONE);
                }
                catch (/** @type {?} */ e) {
                    this.handleError(e);
                }
            }
            return;
        }
        // Default to port 80. If accessing localhost on another port be sure
        // to use http://localhost:port/path
        const /** @type {?} */ port = url.port || (ssl ? 443 : 80);
        // Add query string if one is used
        const /** @type {?} */ uri = url.pathname + (url.search ? url.search : '');
        // Set the defaults if they haven't been set
        for (const /** @type {?} */ name in this.defaultHeaders) {
            if (!this.headersLowerCase[name.toLowerCase()]) {
                this.headers[name] = this.defaultHeaders[name];
            }
        }
        if (host) {
            // Set the Host header or the server may reject the request
            this.headers["Host"] = host;
        }
        // IPv6 addresses must be escaped with brackets
        if (url.host && url.host[0] === '[') {
            this.headers["Host"] = '[' + this.headers["Host"] + ']';
        }
        if (!((ssl && port === 443) || port === 80)) {
            this.headers["Host"] += ':' + url.port;
        }
        // Set Basic Auth if necessary
        if (this.settings.user) {
            if (typeof this.settings.password === 'undefined') {
                this.settings.password = '';
            }
            const /** @type {?} */ authBuf = Buffer.from(this.settings.user + ':' + this.settings.password);
            this.headers["Authorization"] = 'Basic ' + authBuf.toString('base64');
        }
        // Set content length header
        if (this.settings.method === 'GET' || this.settings.method === 'HEAD') {
            data = null;
        }
        else if (data) {
            this.headers['Content-Length'] = '' + (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));
            if (!this.getRequestHeader('Content-Type')) {
                this.headers['Content-Type'] = 'text/plain;charset=UTF-8';
            }
        }
        else if (this.settings.method === 'POST') {
            // For a post with no data set Content-Length: 0.
            // This is required by buggy servers that don't meet the specs.
            this.headers['Content-Length'] = '0';
        }
        const /** @type {?} */ options = {
            host: host,
            port: port,
            path: uri,
            method: this.settings.method,
            headers: this.headers,
            agent: false,
            withCredentials: this.withCredentials
        };
        // Reset error flag
        this.errorFlag = false;
        // Handle async requests
        if (this.settings.async) {
            // handle timeouts correctly
            if (this.timeout >= 1) {
                this.timeoutTimer = setTimeout(() => {
                    if (this.readyState !== this.DONE) {
                        self.handleTimeout(new Error('request timed out after ' + this.timeout + 'ms'));
                    }
                }, this.timeout);
            }
            // Use the proper protocol
            let /** @type {?} */ doRequest = ssl ? request$1 : request;
            // Request is being sent, set send flag
            this.sendFlag = true;
            // As per spec, this is called here for historical reasons.
            self.dispatchEvent('readystatechange');
            // Error handler for the request
            const /** @type {?} */ errorHandler = function (error) {
                self.handleError(error);
            };
            let /** @type {?} */ redirectCount = 0;
            // Handler for the response
            const /** @type {?} */ responseHandler = function (resp) {
                // Set response let to the response we got back
                // This is so it remains accessable outside this scope
                self.response = resp;
                if (self.settings === undefined) {
                    throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');
                }
                // Check for redirect
                if (self.response.headers.location && (self.response.statusCode === 301 ||
                    self.response.statusCode === 302 ||
                    self.response.statusCode === 303 ||
                    self.response.statusCode === 307)) {
                    // increase redirect count
                    redirectCount++;
                    // prevent looped redirects
                    if (redirectCount >= 10) {
                        throw new Error('XMLHttpRequest: Request failed - too many redirects');
                    }
                    // Change URL to the redirect location
                    self.settings.url = self.response.headers.location;
                    const /** @type {?} */ parsedUrl = parse(self.settings.url);
                    // Set host let in case it's used later
                    host = parsedUrl.hostname;
                    // Set host parameter for header or redirect won't work
                    if (host) {
                        self.headers["Host"] = host;
                    }
                    // Options for the new request
                    const /** @type {?} */ newOptions = {
                        hostname: parsedUrl.hostname,
                        port: parsedUrl.port,
                        path: parsedUrl.path,
                        method: self.response.statusCode === 303 ? 'GET' : self.settings.method,
                        headers: self.headers,
                        withCredentials: self.withCredentials
                    };
                    // Update ssl and doRequest to be appropriate
                    // For (potentially) new protocol
                    ssl = (url.protocol === 'https:' ? true : false);
                    doRequest = ssl ? request$1 : request;
                    // Issue the new request
                    self.request = doRequest(newOptions, responseHandler).on('error', errorHandler);
                    self.request.end();
                    // @TODO Check if an XHR event needs to be fired here
                    return;
                }
                self.response.setEncoding('utf8');
                self.setState(self.HEADERS_RECEIVED);
                self.status = self.response.statusCode || 0;
                self.response.on('data', function (chunk) {
                    // Make sure there's some data
                    if (chunk) {
                        self.responseText += chunk;
                    }
                    // Don't emit state changes if the connection has been aborted.
                    if (self.sendFlag) {
                        self.setState(self.LOADING);
                    }
                });
                self.response.on('end', function () {
                    if (self.sendFlag) {
                        // Discard the end event if the connection has been aborted
                        self.setState(self.DONE);
                        self.sendFlag = false;
                    }
                });
                self.response.on('error', function (error) {
                    self.handleError(error);
                });
            };
            // Create the request
            self.request = doRequest(options, responseHandler).on('error', errorHandler);
            // Node 0.4 and later won't accept empty data. Make sure it's needed.
            if (data) {
                self.request.write(data);
            }
            self.request.end();
            self.dispatchEvent('loadstart');
        }
        else {
            // Synchronous
            const /** @type {?} */ startTime = new Date().getTime();
            // Create a temporary file for communication with the other Node process
            const /** @type {?} */ contentFile = tmpdir() + sep + 'ts-xmlhttprequest-content-' + process.pid;
            const /** @type {?} */ syncFile = tmpdir() + sep + 'ts-xmlhttprequest-sync-' + process.pid;
            writeFileSync(syncFile, '', 'utf8');
            // The async request the other Node process executes
            const /** @type {?} */ execString = 'let http = require(\'http\'), https = require(\'https\'), fs = require(\'fs\');'
                + 'let doRequest = http' + (ssl ? 's' : '') + '.request;'
                + 'let options = ' + JSON.stringify(options) + ';'
                + 'let responseText = \'\';'
                + 'let req = doRequest(options, function(response) {'
                + 'response.setEncoding(\'utf8\');'
                + 'response.on(\'data\', function(chunk) {'
                + '    responseText += chunk;'
                + '});'
                + 'response.on(\'end\', function() {'
                + 'fs.writeFileSync('
                + '    \'' + contentFile + '\','
                + '    JSON.stringify({'
                + '        err: null,'
                + '        data: {statusCode: response.statusCode, headers: response.headers, text: responseText}'
                + '    }),'
                + '    \'utf8\''
                + ');'
                + 'fs.unlinkSync(\'' + syncFile + '\');'
                + '});'
                + 'response.on(\'error\', function(error) {'
                + 'fs.writeFileSync(\'' + contentFile + '\', JSON.stringify({err: error}), \'utf8\');'
                + 'fs.unlinkSync(\'' + syncFile + '\');'
                + '});'
                + '}).on(\'error\', function(error) {'
                + 'fs.writeFileSync(\'' + contentFile + '\', JSON.stringify({err: error}), \'utf8\');'
                + 'fs.unlinkSync(\'' + syncFile + '\');'
                + '});'
                + (data ? 'req.write(\'' + JSON.stringify(data).slice(1, -1).replace(/'/g, '\\\'') + '\');' : '')
                + 'req.end();';
            self.dispatchEvent('loadstart');
            this.setState(self.LOADING);
            // Start the other Node Process, executing this string
            const /** @type {?} */ syncProc = spawn(process.argv[0], ['-e', execString]);
            // since this method will run syncronized - this callback always get's called after everything is done
            syncProc.on('exit', function (code, signal) {
                // clean up the temp files
                try {
                    unlinkSync(syncFile);
                }
                catch (/** @type {?} */ e) { }
                try {
                    unlinkSync(contentFile);
                }
                catch (/** @type {?} */ e) { }
            });
            while (existsSync(syncFile)) {
                if (this.timeout !== 0 && new Date().getTime() >= startTime + this.timeout) {
                    // kill the process when we face an error
                    syncProc.stdin.end();
                    syncProc.kill();
                    // handle the timeout error
                    return self.handleTimeout(new Error('request timed out after ' + this.timeout + 'ms'));
                }
            }
            // Kill the child process once the file has data
            syncProc.stdin.end();
            syncProc.kill();
            const /** @type {?} */ resp = JSON.parse(readFileSync(contentFile, 'utf8'));
            // Remove the temporary file
            unlinkSync(contentFile);
            if (resp.err) {
                self.handleError(resp.err);
            }
            else {
                self.response = resp.data;
                self.status = resp.data.statusCode;
                self.responseText = resp.data.text;
                self.setState(self.DONE);
            }
        }
    }
    /**
     * aborts a request
     * @return {?}
     */
    abort() {
        if (this.request) {
            this.request.abort();
            this.request = undefined;
        }
        this.headers = {};
        this.status = 0;
        this.responseText = '';
        this.responseXML = null;
        this.errorFlag = true;
        if (this.readyState !== this.UNSENT &&
            (this.readyState !== this.OPENED || this.sendFlag) &&
            this.readyState !== this.DONE) {
            this.sendFlag = false;
            this.setState(this.DONE);
        }
        this.readyState = this.UNSENT;
        this.dispatchEvent('abort');
    }
    /**
     * adds an event listener to the XMLHttpRequest - this is the preferred method of binding to events
     * @param {?} event
     * @param {?} callback
     * @return {?}
     */
    addEventListener(event, callback) {
        if (!(event in this.listeners)) {
            this.listeners[event] = [];
        }
        // Currently allows duplicate callbacks. Should it?
        this.listeners[event].push(callback);
    }
    /**
     * removes an event callback that has been added with the addEventListener method.
     * @param {?} event
     * @param {?} callback
     * @return {?}
     */
    removeEventListener(event, callback) {
        if (event in this.listeners) {
            // Filter will return a new array with the callback removed
            this.listeners[event] = this.listeners[event].filter(function (ev) {
                return ev !== callback;
            });
        }
    }
    /**
     * dispatches events, including the "on" methods and events attached using addEventListener
     * @param {?} event
     * @param {?=} parameter
     * @return {?}
     */
    dispatchEvent(event, parameter) {
        const /** @type {?} */ eventHandlerMethodName = 'on' + event;
        if (typeof (/** @type {?} */ (this))[eventHandlerMethodName] === 'function') {
            (/** @type {?} */ (this))[eventHandlerMethodName](parameter);
        }
        if (event in this.listeners) {
            for (let /** @type {?} */ i = 0, /** @type {?} */ len = this.listeners[event].length; i < len; i++) {
                this.listeners[event][i].call(this, parameter);
            }
        }
    }
    /**
     * changes readyState and calls onreadystatechange
     * @param {?} state
     * @return {?}
     */
    setState(state) {
        if (state === this.LOADING || this.readyState !== state) {
            this.readyState = state;
            if ((this.settings && this.settings.async) || this.readyState < this.OPENED || this.readyState === this.DONE) {
                this.dispatchEvent('readystatechange');
            }
            if (this.readyState === this.DONE) {
                if (this.timeoutTimer) {
                    clearTimeout(this.timeoutTimer);
                    this.timeoutTimer = undefined;
                }
                if (!this.errorFlag) {
                    this.dispatchEvent('load');
                }
                this.dispatchEvent('loadend');
            }
        }
    }
    /**
     * called when a timeout is encountered
     * @param {?} error
     * @return {?}
     */
    handleTimeout(error) {
        if (this.request) {
            this.request.abort();
            this.request = undefined;
        }
        this.status = 0;
        this.statusText = error.toString();
        this.responseText = error.stack || '';
        this.errorFlag = true;
        this.dispatchEvent('timeout', error);
        this.setState(this.DONE);
    }
    /**
     * called when an error is encountered
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.status = 0;
        this.statusText = error.toString();
        this.responseText = error.stack || '';
        this.errorFlag = true;
        this.dispatchEvent('error', error);
        this.setState(this.DONE);
    }
    /**
     * checks if the specified header is allowed
     * @param {?} header
     * @return {?}
     */
    isAllowedHttpHeader(header) {
        return (this.disableHeaderCheck || (header && this.forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1)) === true;
    }
    /**
     * checks if the specified request method is allowed
     * @param {?} method
     * @return {?}
     */
    isAllowedHttpMethod(method) {
        return (method && this.forbiddenRequestMethods.indexOf(method) === -1) === true;
    }
}
/**
 * constant representing the state an XMLHttpRequest is in after being constructed
 */
XMLHttpRequest.UNSENT = 0;
/**
 * constant representing the state an XMLHttpRequest is in after 'open' was called
 */
XMLHttpRequest.OPENED = 1;
/**
 * constant representing the state an XMLHttpRequest is in when all response headers have been received
 */
XMLHttpRequest.HEADERS_RECEIVED = 2;
/**
 * constant representing the state an XMLHttpRequest is in when either the data transfer has been completed or something went wrong
 */
XMLHttpRequest.LOADING = 3;
/**
 * constant representing the state an XMLHttpRequest is in when the response entity body is being received
 */
XMLHttpRequest.DONE = 4;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { XMLHttpRequest };
//# sourceMappingURL=xmlhttprequest-ts.js.map
