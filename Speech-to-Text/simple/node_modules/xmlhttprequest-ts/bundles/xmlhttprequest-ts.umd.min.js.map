{"version":3,"sources":["xmlhttprequest-ts.umd.js"],"names":["global","factory","exports","module","require","define","amd","CryptoTS","this","fs","http","https","url","os","path","child_process","XMLHttpRequest","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","disableHeaderCheck","readyState","responseText","responseXML","status","statusText","timeout","withCredentials","defaultHeaders","User-Agent","Accept","errorFlag","forbiddenRequestHeaders","forbiddenRequestMethods","headers","headersLowerCase","listeners","sendFlag","prototype","open","method","url$$1","async","user","password","abort","isAllowedHttpMethod","Error","settings","setState","setDisableHeaderCheck","state","setRequestHeader","header","value","isAllowedHttpHeader","toLowerCase","console","warn","getAllResponseHeaders","result","response","i","headerValue","Array","isArray","join","substr","length","getResponseHeader","responseHeader","getRequestHeader","name","send","data","_this","self","undefined","host","ssl","local","parse","protocol","hostname","readFile","unescape","pathname","error","fileData","handleError","readFileSync","e","port","uri","search","name_1","authBuf","Buffer","from","toString","isBuffer","byteLength","options","agent","timeoutTimer","setTimeout","handleTimeout","doRequest_1","request","dispatchEvent","errorHandler_1","redirectCount_1","responseHandler_1","resp","location","statusCode","parsedUrl","newOptions","on","end","setEncoding","chunk","write","startTime","Date","getTime","contentFile_1","tmpdir","sep","process","pid","syncFile_1","writeFileSync","execString","JSON","stringify","slice","replace","syncProc","spawn","argv","code","signal","unlinkSync","existsSync","stdin","kill","err","text","addEventListener","event","callback","push","removeEventListener","filter","ev","parameter","eventHandlerMethodName","len","call","clearTimeout","stack","indexOf","Object","defineProperty"],"mappings":"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","file":"xmlhttprequest-ts.umd.min.js.map","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('fs'), require('http'), require('https'), require('url'), require('os'), require('path'), require('child_process')) :\n    typeof define === 'function' && define.amd ? define('xmlhttprequest-ts', ['exports', 'fs', 'http', 'https', 'url', 'os', 'path', 'child_process'], factory) :\n    (factory((global.CryptoTS = {}),null,null,null,null,null,null,null));\n}(this, (function (exports,fs,http,https,url,os,path,child_process) { 'use strict';\n\n    /**\n     * @license xmlhttprequest-ts\n     * MIT license\n     */\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * defines the node implementaton of the XMLHttpRequest object specs\n     *\n     * see: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n     */\n    var XMLHttpRequest = /** @class */ (function () {\n        function XMLHttpRequest() {\n            /**\n             * constant representing the state an XMLHttpRequest is in after being constructed\n             */\n            this.UNSENT = XMLHttpRequest.UNSENT;\n            /**\n             * constant representing the state an XMLHttpRequest is in after 'open' was called\n             */\n            this.OPENED = XMLHttpRequest.OPENED;\n            /**\n             * constant representing the state an XMLHttpRequest is in when all response headers have been received\n             */\n            this.HEADERS_RECEIVED = XMLHttpRequest.HEADERS_RECEIVED;\n            /**\n             * constant representing the state an XMLHttpRequest is in when either the data transfer has been completed or something went wrong\n             */\n            this.LOADING = XMLHttpRequest.LOADING;\n            /**\n             * constant representing the state an XMLHttpRequest is in when the response entity body is being received\n             */\n            this.DONE = XMLHttpRequest.DONE;\n            /**\n             * option to disable the builtin header blacklist\n             *\n             * IMPORTANT: this is not part of the XHR specs\n             */\n            this.disableHeaderCheck = false;\n            /**\n             * stores the ready state of the request (see UNSENT, OPENED, HEADERS_RECEIVED, LOADING, DONE)\n             */\n            this.readyState = XMLHttpRequest.UNSENT;\n            /**\n             * the text received from a server following a request being sent\n             */\n            this.responseText = '';\n            /**\n             * usually contains a document instance of the parsed request result but since the dom isn't available in node, this is always null\n             */\n            this.responseXML = null;\n            /**\n             * the numerical status code of the response\n             */\n            this.status = 0;\n            /**\n             * the text received from a server following a request being sent\n             */\n            this.statusText = '';\n            /**\n             * timeout in milliseconds after a request should time out\n             */\n            this.timeout = 0;\n            /**\n             * indicates whether or not cross-site Access-Control requests should be made using credentials like authorization headers\n             */\n            this.withCredentials = false;\n            /**\n             * defines the default headers sent by our requests\n             */\n            this.defaultHeaders = {\n                'User-Agent': 'ts-XMLHttpRequest',\n                'Accept': '*/*'\n            };\n            /**\n             * error flag, used when errors occur or abort is called\n             */\n            this.errorFlag = false;\n            /**\n             * list of headers that are not setable by the user according to the specs\n             *\n             * IMPORTNAT: this can optionally be disabled by setting disableHeaderCheck to true\n             */\n            this.forbiddenRequestHeaders = [\n                'accept-charset',\n                'accept-encoding',\n                'access-control-request-headers',\n                'access-control-request-method',\n                'connection',\n                'content-length',\n                'content-transfer-encoding',\n                'cookie',\n                'cookie2',\n                'date',\n                'expect',\n                'host',\n                'keep-alive',\n                'origin',\n                'referer',\n                'te',\n                'trailer',\n                'transfer-encoding',\n                'upgrade',\n                'via'\n            ];\n            /**\n             * list of request methods that are not setable by the user according to the specs\n             */\n            this.forbiddenRequestMethods = [\n                'TRACE',\n                'TRACK',\n                'CONNECT'\n            ];\n            /**\n             * stores the headers that are used for this request\n             */\n            this.headers = {};\n            /**\n             * stores the headers that are used for this request with the name being lower-cased\n             */\n            this.headersLowerCase = {};\n            /**\n             * stores the event listeners that have been set via the addEventListener method\n             */\n            this.listeners = {};\n            /**\n             * flag indicating if a request was sent already\n             */\n            this.sendFlag = false;\n        }\n        /**\n         * Open the connection. Currently supports local server requests.\n         *\n         * @param {?} method Connection method (eg GET, POST)\n         * @param {?} url URL for the connection.\n         * @param {?=} async Asynchronous connection (optional - default is true)\n         * @param {?=} user Username for basic authentication (optional)\n         * @param {?=} password Password for basic authentication (optional)\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.open = /**\n         * Open the connection. Currently supports local server requests.\n         *\n         * @param {?} method Connection method (eg GET, POST)\n         * @param {?} url URL for the connection.\n         * @param {?=} async Asynchronous connection (optional - default is true)\n         * @param {?=} user Username for basic authentication (optional)\n         * @param {?=} password Password for basic authentication (optional)\n         * @return {?}\n         */\n        function (method, url$$1, async, user, password) {\n            if (async === void 0) { async = true; }\n            this.abort();\n            this.errorFlag = false;\n            // Check for valid request method\n            if (!this.isAllowedHttpMethod(method)) {\n                throw new Error('SecurityError: Request method not allowed');\n            }\n            this.settings = {\n                'method': method,\n                'url': url$$1,\n                'async': (typeof async !== 'boolean' ? true : async),\n                'user': user,\n                'password': password\n            };\n            this.setState(this.OPENED);\n        };\n        /**\n         * disables or enables the check of allowed headers in the request\n         *\n         * IMPORTANT: this is not part of the W3C spec\n         *\n         * @param {?} state Enable or disable header checking.\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.setDisableHeaderCheck = /**\n         * disables or enables the check of allowed headers in the request\n         *\n         * IMPORTANT: this is not part of the W3C spec\n         *\n         * @param {?} state Enable or disable header checking.\n         * @return {?}\n         */\n        function (state) {\n            this.disableHeaderCheck = state;\n        };\n        /**\n         * sets a header for the request or appends the value if one is already set\n         *\n         * @param {?} header header name\n         * @param {?} value header value\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.setRequestHeader = /**\n         * sets a header for the request or appends the value if one is already set\n         *\n         * @param {?} header header name\n         * @param {?} value header value\n         * @return {?}\n         */\n        function (header, value) {\n            if (this.readyState !== this.OPENED) {\n                throw new Error('INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN');\n            }\n            if (!this.isAllowedHttpHeader(header)) {\n                console.warn('Refused to set unsafe header \\\"' + header + '\\\"');\n                return;\n            }\n            if (this.sendFlag) {\n                throw new Error('INVALID_STATE_ERR: send flag is true');\n            }\n            header = this.headersLowerCase[header.toLowerCase()] || header;\n            this.headersLowerCase[header.toLowerCase()] = header;\n            this.headers[header] = this.headers[header] ? this.headers[header] + ', ' + value : value;\n        };\n        /**\n         * returns all the response headers, separated by CRLF, as a string, or null if no response has been received\n         *\n         * @return {?} a string with all response headers separated by CR+LF, or null if no response has been received\n         */\n        XMLHttpRequest.prototype.getAllResponseHeaders = /**\n         * returns all the response headers, separated by CRLF, as a string, or null if no response has been received\n         *\n         * @return {?} a string with all response headers separated by CR+LF, or null if no response has been received\n         */\n        function () {\n            if (this.readyState < this.HEADERS_RECEIVED || this.errorFlag) {\n                return null;\n            }\n            var /** @type {?} */ result = '';\n            if (this.response) {\n                for (var /** @type {?} */ i in this.response.headers) {\n                    // Cookie headers are excluded\n                    if (i !== 'set-cookie' && i !== 'set-cookie2') {\n                        var /** @type {?} */ headerValue = this.response.headers[i];\n                        if (typeof headerValue === 'string') {\n                            result += i + ': ' + headerValue + '\\r\\n';\n                        }\n                        else if (Array.isArray(headerValue)) {\n                            result += i + ': ' + headerValue.join(', ') + '\\r\\n';\n                        }\n                        else {\n                            result += i + ':\\r\\n';\n                        }\n                    }\n                }\n            }\n            return result.substr(0, result.length - 2);\n        };\n        /**\n         * gets a header from the server response.\n         *\n         * @param {?} header\n         * @return {?} text of the header or null if it doesn't exist.\n         */\n        XMLHttpRequest.prototype.getResponseHeader = /**\n         * gets a header from the server response.\n         *\n         * @param {?} header\n         * @return {?} text of the header or null if it doesn't exist.\n         */\n        function (header) {\n            if (typeof header === 'string' &&\n                this.readyState > this.OPENED &&\n                this.response &&\n                this.response.headers &&\n                this.response.headers[header.toLowerCase()] &&\n                !this.errorFlag) {\n                var /** @type {?} */ responseHeader = this.response.headers[header.toLowerCase()];\n                if (typeof responseHeader === 'string') {\n                    return responseHeader;\n                }\n                if (Array.isArray(responseHeader)) {\n                    return responseHeader.join(', ');\n                }\n            }\n            return null;\n        };\n        /**\n         * gets a request header that was set in this instance\n         *\n         * IMPORTANT: this is not part of the W3C specs\n         *\n         * @param {?} name\n         * @return {?} returns the request header or empty string if not set\n         */\n        XMLHttpRequest.prototype.getRequestHeader = /**\n         * gets a request header that was set in this instance\n         *\n         * IMPORTANT: this is not part of the W3C specs\n         *\n         * @param {?} name\n         * @return {?} returns the request header or empty string if not set\n         */\n        function (name) {\n            if (typeof name === 'string' && this.headersLowerCase[name.toLowerCase()]) {\n                return this.headers[this.headersLowerCase[name.toLowerCase()]];\n            }\n            return undefined;\n        };\n        /**\n         * sends the request to the server.\n         *\n         * @param {?=} data\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.send = /**\n         * sends the request to the server.\n         *\n         * @param {?=} data\n         * @return {?}\n         */\n        function (data) {\n            var _this = this;\n            var /** @type {?} */ self = this;\n            if (this.settings === undefined) {\n                throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n            }\n            if (this.readyState !== this.OPENED) {\n                throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n            }\n            if (this.sendFlag) {\n                throw new Error('INVALID_STATE_ERR: send has already been called');\n            }\n            var /** @type {?} */ ssl = false, /** @type {?} */ local = false;\n            var /** @type {?} */ url$$1 = url.parse(this.settings.url);\n            var /** @type {?} */ host;\n            // Determine the server\n            switch (url$$1.protocol) {\n                case 'https:':\n                    ssl = true;\n                // SSL & non-SSL both need host, no break here.\n                case 'http:':\n                    host = url$$1.hostname;\n                    break;\n                case 'file:':\n                    local = true;\n                    break;\n                case undefined:\n                case null:\n                case '':\n                    host = 'localhost';\n                    break;\n                default:\n                    throw new Error('Protocol not supported.');\n            }\n            // Load files off the local filesystem (file://)\n            if (local) {\n                if (this.settings.method !== 'GET') {\n                    throw new Error('XMLHttpRequest: Only GET method is supported');\n                }\n                if (this.settings.async) {\n                    fs.readFile(unescape(url$$1.pathname || '/'), 'utf8', function (error, fileData) {\n                        if (error) {\n                            self.handleError(error);\n                        }\n                        else {\n                            self.status = 200;\n                            self.responseText = fileData;\n                            self.setState(self.DONE);\n                        }\n                    });\n                }\n                else {\n                    try {\n                        this.responseText = fs.readFileSync(unescape(url$$1.pathname || '/'), 'utf8');\n                        this.status = 200;\n                        this.setState(self.DONE);\n                    }\n                    catch (/** @type {?} */ e) {\n                        this.handleError(e);\n                    }\n                }\n                return;\n            }\n            // Default to port 80. If accessing localhost on another port be sure\n            // to use http://localhost:port/path\n            var /** @type {?} */ port = url$$1.port || (ssl ? 443 : 80);\n            // Add query string if one is used\n            var /** @type {?} */ uri = url$$1.pathname + (url$$1.search ? url$$1.search : '');\n            // Set the defaults if they haven't been set\n            for (var /** @type {?} */ name_1 in this.defaultHeaders) {\n                if (!this.headersLowerCase[name_1.toLowerCase()]) {\n                    this.headers[name_1] = this.defaultHeaders[name_1];\n                }\n            }\n            if (host) {\n                // Set the Host header or the server may reject the request\n                this.headers[\"Host\"] = host;\n            }\n            // IPv6 addresses must be escaped with brackets\n            if (url$$1.host && url$$1.host[0] === '[') {\n                this.headers[\"Host\"] = '[' + this.headers[\"Host\"] + ']';\n            }\n            if (!((ssl && port === 443) || port === 80)) {\n                this.headers[\"Host\"] += ':' + url$$1.port;\n            }\n            // Set Basic Auth if necessary\n            if (this.settings.user) {\n                if (typeof this.settings.password === 'undefined') {\n                    this.settings.password = '';\n                }\n                var /** @type {?} */ authBuf = Buffer.from(this.settings.user + ':' + this.settings.password);\n                this.headers[\"Authorization\"] = 'Basic ' + authBuf.toString('base64');\n            }\n            // Set content length header\n            if (this.settings.method === 'GET' || this.settings.method === 'HEAD') {\n                data = null;\n            }\n            else if (data) {\n                this.headers['Content-Length'] = '' + (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));\n                if (!this.getRequestHeader('Content-Type')) {\n                    this.headers['Content-Type'] = 'text/plain;charset=UTF-8';\n                }\n            }\n            else if (this.settings.method === 'POST') {\n                // For a post with no data set Content-Length: 0.\n                // This is required by buggy servers that don't meet the specs.\n                this.headers['Content-Length'] = '0';\n            }\n            var /** @type {?} */ options = {\n                host: host,\n                port: port,\n                path: uri,\n                method: this.settings.method,\n                headers: this.headers,\n                agent: false,\n                withCredentials: this.withCredentials\n            };\n            // Reset error flag\n            this.errorFlag = false;\n            // Handle async requests\n            if (this.settings.async) {\n                // handle timeouts correctly\n                if (this.timeout >= 1) {\n                    this.timeoutTimer = setTimeout(function () {\n                        if (_this.readyState !== _this.DONE) {\n                            self.handleTimeout(new Error('request timed out after ' + _this.timeout + 'ms'));\n                        }\n                    }, this.timeout);\n                }\n                // Use the proper protocol\n                var /** @type {?} */ doRequest_1 = ssl ? https.request : http.request;\n                // Request is being sent, set send flag\n                this.sendFlag = true;\n                // As per spec, this is called here for historical reasons.\n                self.dispatchEvent('readystatechange');\n                // Error handler for the request\n                var /** @type {?} */ errorHandler_1 = function (error) {\n                    self.handleError(error);\n                };\n                var /** @type {?} */ redirectCount_1 = 0;\n                // Handler for the response\n                var /** @type {?} */ responseHandler_1 = function (resp) {\n                    // Set response let to the response we got back\n                    // This is so it remains accessable outside this scope\n                    self.response = resp;\n                    if (self.settings === undefined) {\n                        throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n                    }\n                    // Check for redirect\n                    if (self.response.headers.location && (self.response.statusCode === 301 ||\n                        self.response.statusCode === 302 ||\n                        self.response.statusCode === 303 ||\n                        self.response.statusCode === 307)) {\n                        // increase redirect count\n                        // increase redirect count\n                        redirectCount_1++;\n                        // prevent looped redirects\n                        if (redirectCount_1 >= 10) {\n                            throw new Error('XMLHttpRequest: Request failed - too many redirects');\n                        }\n                        // Change URL to the redirect location\n                        self.settings.url = self.response.headers.location;\n                        var /** @type {?} */ parsedUrl = url.parse(self.settings.url);\n                        // Set host let in case it's used later\n                        host = parsedUrl.hostname;\n                        // Set host parameter for header or redirect won't work\n                        if (host) {\n                            self.headers[\"Host\"] = host;\n                        }\n                        // Options for the new request\n                        var /** @type {?} */ newOptions = {\n                            hostname: parsedUrl.hostname,\n                            port: parsedUrl.port,\n                            path: parsedUrl.path,\n                            method: self.response.statusCode === 303 ? 'GET' : self.settings.method,\n                            headers: self.headers,\n                            withCredentials: self.withCredentials\n                        };\n                        // Update ssl and doRequest to be appropriate\n                        // For (potentially) new protocol\n                        ssl = (url$$1.protocol === 'https:' ? true : false);\n                        doRequest_1 = ssl ? https.request : http.request;\n                        // Issue the new request\n                        self.request = doRequest_1(newOptions, responseHandler_1).on('error', errorHandler_1);\n                        self.request.end();\n                        // @TODO Check if an XHR event needs to be fired here\n                        return;\n                    }\n                    self.response.setEncoding('utf8');\n                    self.setState(self.HEADERS_RECEIVED);\n                    self.status = self.response.statusCode || 0;\n                    self.response.on('data', function (chunk) {\n                        // Make sure there's some data\n                        if (chunk) {\n                            self.responseText += chunk;\n                        }\n                        // Don't emit state changes if the connection has been aborted.\n                        if (self.sendFlag) {\n                            self.setState(self.LOADING);\n                        }\n                    });\n                    self.response.on('end', function () {\n                        if (self.sendFlag) {\n                            // Discard the end event if the connection has been aborted\n                            self.setState(self.DONE);\n                            self.sendFlag = false;\n                        }\n                    });\n                    self.response.on('error', function (error) {\n                        self.handleError(error);\n                    });\n                };\n                // Create the request\n                self.request = doRequest_1(options, responseHandler_1).on('error', errorHandler_1);\n                // Node 0.4 and later won't accept empty data. Make sure it's needed.\n                if (data) {\n                    self.request.write(data);\n                }\n                self.request.end();\n                self.dispatchEvent('loadstart');\n            }\n            else {\n                // Synchronous\n                var /** @type {?} */ startTime = new Date().getTime();\n                // Create a temporary file for communication with the other Node process\n                var /** @type {?} */ contentFile_1 = os.tmpdir() + path.sep + 'ts-xmlhttprequest-content-' + process.pid;\n                var /** @type {?} */ syncFile_1 = os.tmpdir() + path.sep + 'ts-xmlhttprequest-sync-' + process.pid;\n                fs.writeFileSync(syncFile_1, '', 'utf8');\n                // The async request the other Node process executes\n                var /** @type {?} */ execString = 'let http = require(\\'http\\'), https = require(\\'https\\'), fs = require(\\'fs\\');'\n                    + 'let doRequest = http' + (ssl ? 's' : '') + '.request;'\n                    + 'let options = ' + JSON.stringify(options) + ';'\n                    + 'let responseText = \\'\\';'\n                    + 'let req = doRequest(options, function(response) {'\n                    + 'response.setEncoding(\\'utf8\\');'\n                    + 'response.on(\\'data\\', function(chunk) {'\n                    + '    responseText += chunk;'\n                    + '});'\n                    + 'response.on(\\'end\\', function() {'\n                    + 'fs.writeFileSync('\n                    + '    \\'' + contentFile_1 + '\\','\n                    + '    JSON.stringify({'\n                    + '        err: null,'\n                    + '        data: {statusCode: response.statusCode, headers: response.headers, text: responseText}'\n                    + '    }),'\n                    + '    \\'utf8\\''\n                    + ');'\n                    + 'fs.unlinkSync(\\'' + syncFile_1 + '\\');'\n                    + '});'\n                    + 'response.on(\\'error\\', function(error) {'\n                    + 'fs.writeFileSync(\\'' + contentFile_1 + '\\', JSON.stringify({err: error}), \\'utf8\\');'\n                    + 'fs.unlinkSync(\\'' + syncFile_1 + '\\');'\n                    + '});'\n                    + '}).on(\\'error\\', function(error) {'\n                    + 'fs.writeFileSync(\\'' + contentFile_1 + '\\', JSON.stringify({err: error}), \\'utf8\\');'\n                    + 'fs.unlinkSync(\\'' + syncFile_1 + '\\');'\n                    + '});'\n                    + (data ? 'req.write(\\'' + JSON.stringify(data).slice(1, -1).replace(/'/g, '\\\\\\'') + '\\');' : '')\n                    + 'req.end();';\n                self.dispatchEvent('loadstart');\n                this.setState(self.LOADING);\n                // Start the other Node Process, executing this string\n                var /** @type {?} */ syncProc = child_process.spawn(process.argv[0], ['-e', execString]);\n                // since this method will run syncronized - this callback always get's called after everything is done\n                syncProc.on('exit', function (code, signal) {\n                    // clean up the temp files\n                    try {\n                        fs.unlinkSync(syncFile_1);\n                    }\n                    catch (/** @type {?} */ e) { }\n                    try {\n                        fs.unlinkSync(contentFile_1);\n                    }\n                    catch (/** @type {?} */ e) { }\n                });\n                while (fs.existsSync(syncFile_1)) {\n                    if (this.timeout !== 0 && new Date().getTime() >= startTime + this.timeout) {\n                        // kill the process when we face an error\n                        syncProc.stdin.end();\n                        syncProc.kill();\n                        // handle the timeout error\n                        return self.handleTimeout(new Error('request timed out after ' + this.timeout + 'ms'));\n                    }\n                }\n                // Kill the child process once the file has data\n                syncProc.stdin.end();\n                syncProc.kill();\n                var /** @type {?} */ resp = JSON.parse(fs.readFileSync(contentFile_1, 'utf8'));\n                // Remove the temporary file\n                fs.unlinkSync(contentFile_1);\n                if (resp.err) {\n                    self.handleError(resp.err);\n                }\n                else {\n                    self.response = resp.data;\n                    self.status = resp.data.statusCode;\n                    self.responseText = resp.data.text;\n                    self.setState(self.DONE);\n                }\n            }\n        };\n        /**\n         * aborts a request\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.abort = /**\n         * aborts a request\n         * @return {?}\n         */\n        function () {\n            if (this.request) {\n                this.request.abort();\n                this.request = undefined;\n            }\n            this.headers = {};\n            this.status = 0;\n            this.responseText = '';\n            this.responseXML = null;\n            this.errorFlag = true;\n            if (this.readyState !== this.UNSENT &&\n                (this.readyState !== this.OPENED || this.sendFlag) &&\n                this.readyState !== this.DONE) {\n                this.sendFlag = false;\n                this.setState(this.DONE);\n            }\n            this.readyState = this.UNSENT;\n            this.dispatchEvent('abort');\n        };\n        /**\n         * adds an event listener to the XMLHttpRequest - this is the preferred method of binding to events\n         * @param {?} event\n         * @param {?} callback\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.addEventListener = /**\n         * adds an event listener to the XMLHttpRequest - this is the preferred method of binding to events\n         * @param {?} event\n         * @param {?} callback\n         * @return {?}\n         */\n        function (event, callback) {\n            if (!(event in this.listeners)) {\n                this.listeners[event] = [];\n            }\n            // Currently allows duplicate callbacks. Should it?\n            this.listeners[event].push(callback);\n        };\n        /**\n         * removes an event callback that has been added with the addEventListener method.\n         * @param {?} event\n         * @param {?} callback\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.removeEventListener = /**\n         * removes an event callback that has been added with the addEventListener method.\n         * @param {?} event\n         * @param {?} callback\n         * @return {?}\n         */\n        function (event, callback) {\n            if (event in this.listeners) {\n                // Filter will return a new array with the callback removed\n                this.listeners[event] = this.listeners[event].filter(function (ev) {\n                    return ev !== callback;\n                });\n            }\n        };\n        /**\n         * dispatches events, including the \"on\" methods and events attached using addEventListener\n         * @param {?} event\n         * @param {?=} parameter\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.dispatchEvent = /**\n         * dispatches events, including the \"on\" methods and events attached using addEventListener\n         * @param {?} event\n         * @param {?=} parameter\n         * @return {?}\n         */\n        function (event, parameter) {\n            var /** @type {?} */ eventHandlerMethodName = 'on' + event;\n            if (typeof (/** @type {?} */ (this))[eventHandlerMethodName] === 'function') {\n                (/** @type {?} */ (this))[eventHandlerMethodName](parameter);\n            }\n            if (event in this.listeners) {\n                for (var /** @type {?} */ i = 0, /** @type {?} */ len = this.listeners[event].length; i < len; i++) {\n                    this.listeners[event][i].call(this, parameter);\n                }\n            }\n        };\n        /**\n         * changes readyState and calls onreadystatechange\n         * @param {?} state\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.setState = /**\n         * changes readyState and calls onreadystatechange\n         * @param {?} state\n         * @return {?}\n         */\n        function (state) {\n            if (state === this.LOADING || this.readyState !== state) {\n                this.readyState = state;\n                if ((this.settings && this.settings.async) || this.readyState < this.OPENED || this.readyState === this.DONE) {\n                    this.dispatchEvent('readystatechange');\n                }\n                if (this.readyState === this.DONE) {\n                    if (this.timeoutTimer) {\n                        clearTimeout(this.timeoutTimer);\n                        this.timeoutTimer = undefined;\n                    }\n                    if (!this.errorFlag) {\n                        this.dispatchEvent('load');\n                    }\n                    this.dispatchEvent('loadend');\n                }\n            }\n        };\n        /**\n         * called when a timeout is encountered\n         * @param {?} error\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.handleTimeout = /**\n         * called when a timeout is encountered\n         * @param {?} error\n         * @return {?}\n         */\n        function (error) {\n            if (this.request) {\n                this.request.abort();\n                this.request = undefined;\n            }\n            this.status = 0;\n            this.statusText = error.toString();\n            this.responseText = error.stack || '';\n            this.errorFlag = true;\n            this.dispatchEvent('timeout', error);\n            this.setState(this.DONE);\n        };\n        /**\n         * called when an error is encountered\n         * @param {?} error\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.handleError = /**\n         * called when an error is encountered\n         * @param {?} error\n         * @return {?}\n         */\n        function (error) {\n            this.status = 0;\n            this.statusText = error.toString();\n            this.responseText = error.stack || '';\n            this.errorFlag = true;\n            this.dispatchEvent('error', error);\n            this.setState(this.DONE);\n        };\n        /**\n         * checks if the specified header is allowed\n         * @param {?} header\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.isAllowedHttpHeader = /**\n         * checks if the specified header is allowed\n         * @param {?} header\n         * @return {?}\n         */\n        function (header) {\n            return (this.disableHeaderCheck || (header && this.forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1)) === true;\n        };\n        /**\n         * checks if the specified request method is allowed\n         * @param {?} method\n         * @return {?}\n         */\n        XMLHttpRequest.prototype.isAllowedHttpMethod = /**\n         * checks if the specified request method is allowed\n         * @param {?} method\n         * @return {?}\n         */\n        function (method) {\n            return (method && this.forbiddenRequestMethods.indexOf(method) === -1) === true;\n        };\n        /**\n         * constant representing the state an XMLHttpRequest is in after being constructed\n         */\n        XMLHttpRequest.UNSENT = 0;\n        /**\n         * constant representing the state an XMLHttpRequest is in after 'open' was called\n         */\n        XMLHttpRequest.OPENED = 1;\n        /**\n         * constant representing the state an XMLHttpRequest is in when all response headers have been received\n         */\n        XMLHttpRequest.HEADERS_RECEIVED = 2;\n        /**\n         * constant representing the state an XMLHttpRequest is in when either the data transfer has been completed or something went wrong\n         */\n        XMLHttpRequest.LOADING = 3;\n        /**\n         * constant representing the state an XMLHttpRequest is in when the response entity body is being received\n         */\n        XMLHttpRequest.DONE = 4;\n        return XMLHttpRequest;\n    }());\n\n    exports.XMLHttpRequest = XMLHttpRequest;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=xmlhttprequest-ts.umd.js.map\n"]}