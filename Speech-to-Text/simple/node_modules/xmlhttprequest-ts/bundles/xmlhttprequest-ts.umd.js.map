{"version":3,"file":"xmlhttprequest-ts.umd.js","sources":["../../src/XMLHttpRequest.ts"],"sourcesContent":["// import required node.js core dependencies ///////////////////////////////////////////////////////\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport * as Url from 'url';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { ClientRequest, IncomingMessage } from 'http';\nimport { spawn } from 'child_process';\n\n// import required local dependencies //////////////////////////////////////////////////////////////\nimport { HttpHeaders } from './HttpHeaders';\nimport { XMLHttpRequestSettings } from './XMLHttpRequestSettings';\nimport { XMLHttpRequestListeners } from './XMLHttpRequestListeners';\n\n/**\n * defines the node implementaton of the XMLHttpRequest object specs\n *\n * see: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */\nexport class XMLHttpRequest {\n    // class constants /////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * constant representing the state an XMLHttpRequest is in after being constructed\n     */\n    public static UNSENT = 0;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in after 'open' was called\n     */\n    public static OPENED = 1;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when all response headers have been received\n     */\n    public static HEADERS_RECEIVED = 2;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when either the data transfer has been completed or something went wrong\n     */\n    public static LOADING = 3;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when the response entity body is being received\n     */\n    public static DONE = 4;\n\n    // instance constants //////////////////////////////////////////////////////////////////////////\n\n    /**\n     * constant representing the state an XMLHttpRequest is in after being constructed\n     */\n    public UNSENT = XMLHttpRequest.UNSENT;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in after 'open' was called\n     */\n    public OPENED = XMLHttpRequest.OPENED;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when all response headers have been received\n     */\n    public HEADERS_RECEIVED = XMLHttpRequest.HEADERS_RECEIVED;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when either the data transfer has been completed or something went wrong\n     */\n    public LOADING = XMLHttpRequest.LOADING;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when the response entity body is being received\n     */\n    public DONE = XMLHttpRequest.DONE;\n\n    // public instance members /////////////////////////////////////////////////////////////////////\n\n    /**\n     * option to disable the builtin header blacklist\n     *\n     * IMPORTANT: this is not part of the XHR specs\n     */\n    public disableHeaderCheck = false;\n\n    /**\n     * an EventHandler that is called whenever the readyState attribute changes\n     */\n    public onreadystatechange?: () => any;\n\n    /**\n     * an EventHandler that is called whenever an abort occurs\n     */\n    public onabort?: () => any;\n\n    /**\n     * an EventHandler that is called whenever an error occurs\n     */\n    public onerror?: (err: Error) => any;\n\n    /**\n     * an EventHandler that is called whenever a request loads successfully\n     */\n    public onload?: () => any;\n\n    /**\n     * an EventHandler that is called whenever a request finished\n     */\n    public onloadend?: () => any;\n\n    /**\n     * an EventHandler that is called whenever a request starts to load\n     */\n    public onloadstart?: () => any;\n\n    /**\n     * an EventHandler that is called whenever a timeout occurs\n     */\n    public ontimeout?: (err: Error) => any;\n\n    /**\n     * stores the ready state of the request (see UNSENT, OPENED, HEADERS_RECEIVED, LOADING, DONE)\n     */\n    public readyState = XMLHttpRequest.UNSENT;\n\n    /**\n     * the text received from a server following a request being sent\n     */\n    public responseText = '';\n\n    /**\n     * usually contains a document instance of the parsed request result but since the dom isn't available in node, this is always null\n     */\n    public responseXML: null = null;\n\n    /**\n     * the numerical status code of the response\n     */\n    public status = 0;\n\n    /**\n     * the text received from a server following a request being sent\n     */\n    public statusText = '';\n\n    /**\n     * timeout in milliseconds after a request should time out\n     */\n    public timeout = 0;\n\n    /**\n     * indicates whether or not cross-site Access-Control requests should be made using credentials like authorization headers\n     */\n    public withCredentials = false;\n\n    // private instance members ////////////////////////////////////////////////////////////////////\n\n    /**\n     * defines the default headers sent by our requests\n     */\n    private defaultHeaders: HttpHeaders = {\n        'User-Agent': 'ts-XMLHttpRequest',\n        'Accept': '*/*'\n    };\n\n    /**\n     * error flag, used when errors occur or abort is called\n     */\n    private errorFlag = false;\n\n    /**\n     * list of headers that are not setable by the user according to the specs\n     *\n     * IMPORTNAT: this can optionally be disabled by setting disableHeaderCheck to true\n     */\n    private forbiddenRequestHeaders: Array<string> = [\n        'accept-charset',\n        'accept-encoding',\n        'access-control-request-headers',\n        'access-control-request-method',\n        'connection',\n        'content-length',\n        'content-transfer-encoding',\n        'cookie',\n        'cookie2',\n        'date',\n        'expect',\n        'host',\n        'keep-alive',\n        'origin',\n        'referer',\n        'te',\n        'trailer',\n        'transfer-encoding',\n        'upgrade',\n        'via'\n    ];\n\n    /**\n     * list of request methods that are not setable by the user according to the specs\n     */\n    private forbiddenRequestMethods: Array<string> = [\n        'TRACE',\n        'TRACK',\n        'CONNECT'\n    ];\n\n    /**\n     * stores the headers that are used for this request\n     */\n    private headers: HttpHeaders = {};\n\n    /**\n     * stores the headers that are used for this request with the name being lower-cased\n     */\n    private headersLowerCase: HttpHeaders = {};\n\n    /**\n     * stores the event listeners that have been set via the addEventListener method\n     */\n    private listeners: XMLHttpRequestListeners = {};\n\n    /**\n     * stores a reference to the request object of node.js\n     */\n    private request?: ClientRequest;\n\n    /**\n     * stores a reference to the response object of node.js\n     */\n    private response?: IncomingMessage;\n\n    /**\n     * flag indicating if a request was sent already\n     */\n    private sendFlag = false;\n\n    /**\n     * stores the settings of this object which are set when calling \"open\"\n     */\n    private settings?: XMLHttpRequestSettings;\n\n    /**\n     * stores the timer that is used for timeouts\n     */\n    timeoutTimer?: NodeJS.Timer;\n\n    // public instance methods /////////////////////////////////////////////////////////////////////\n\n    /**\n     * Open the connection. Currently supports local server requests.\n     *\n     * @param method Connection method (eg GET, POST)\n     * @param url URL for the connection.\n     * @param async Asynchronous connection (optional - default is true)\n     * @param user Username for basic authentication (optional)\n     * @param password Password for basic authentication (optional)\n     */\n    public open(method: string, url: string, async: boolean = true, user?: string, password?: string) {\n        this.abort();\n\n        this.errorFlag = false;\n\n        // Check for valid request method\n        if(!this.isAllowedHttpMethod(method)) {\n            throw new Error('SecurityError: Request method not allowed');\n        }\n\n        this.settings = {\n            'method': method,\n            'url': url,\n            'async': (typeof async !== 'boolean' ? true : async),\n            'user': user,\n            'password': password\n        };\n\n        this.setState(this.OPENED);\n    }\n\n    /**\n     * disables or enables the check of allowed headers in the request\n     *\n     * IMPORTANT: this is not part of the W3C spec\n     *\n     * @param state Enable or disable header checking.\n     */\n    public setDisableHeaderCheck(state: boolean): void {\n        this.disableHeaderCheck = state;\n    }\n\n    /**\n     * sets a header for the request or appends the value if one is already set\n     *\n     * @param header header name\n     * @param value header value\n     */\n    public setRequestHeader(header: string, value: string) {\n        if(this.readyState !== this.OPENED) {\n            throw new Error('INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN');\n        }\n\n        if(!this.isAllowedHttpHeader(header)) {\n            console.warn('Refused to set unsafe header \\\"' + header + '\\\"');\n\n            return;\n        }\n\n        if(this.sendFlag) {\n            throw new Error('INVALID_STATE_ERR: send flag is true');\n        }\n\n        header = this.headersLowerCase[header.toLowerCase()] || header;\n        this.headersLowerCase[header.toLowerCase()] = header;\n        this.headers[header] = this.headers[header] ? this.headers[header] + ', ' + value : value;\n    }\n\n    /**\n     * returns all the response headers, separated by CRLF, as a string, or null if no response has been received\n     *\n     * @return a string with all response headers separated by CR+LF, or null if no response has been received\n     */\n    public getAllResponseHeaders() {\n        if(this.readyState < this.HEADERS_RECEIVED || this.errorFlag) {\n            return null;\n        }\n\n        let result = '';\n        if(this.response) {\n            for(const i in this.response.headers) {\n                // Cookie headers are excluded\n                if(i !== 'set-cookie' && i !== 'set-cookie2') {\n                    const headerValue: string | Array<string> | undefined = this.response.headers[i];\n\n                    if(typeof headerValue === 'string') {\n                        result += i + ': ' + headerValue + '\\r\\n';\n                    } else if(Array.isArray(headerValue)) {\n                        result += i + ': ' + headerValue.join(', ') + '\\r\\n';\n                    } else {\n                        result += i + ':\\r\\n';\n                    }\n                }\n            }\n        }\n\n        return result.substr(0, result.length - 2);\n    }\n\n    /**\n     * gets a header from the server response.\n     *\n     * @return text of the header or null if it doesn't exist.\n     */\n    public getResponseHeader(header: string): string | null {\n        if(\n            typeof header === 'string' &&\n            this.readyState > this.OPENED &&\n            this.response &&\n            this.response.headers &&\n            this.response.headers[header.toLowerCase()] &&\n            !this.errorFlag\n        ) {\n            const responseHeader: string | string[] | undefined = this.response.headers[header.toLowerCase()];\n\n            if(typeof responseHeader === 'string') {\n                return responseHeader;\n            }\n\n            if(Array.isArray(responseHeader)) {\n                return responseHeader.join(', ');\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * gets a request header that was set in this instance\n     *\n     * IMPORTANT: this is not part of the W3C specs\n     *\n     * @return returns the request header or empty string if not set\n     */\n    public getRequestHeader(name: string): string | undefined {\n        if(typeof name === 'string' && this.headersLowerCase[name.toLowerCase()]) {\n            return this.headers[this.headersLowerCase[name.toLowerCase()]];\n        }\n\n        return undefined;\n    }\n\n    /**\n     * sends the request to the server.\n     *\n     * @param string data Optional data to send as request body.\n     */\n    public send(data?: any) {\n        const self = this;\n\n        if(this.settings === undefined) {\n            throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n        }\n\n        if(this.readyState !== this.OPENED) {\n            throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n        }\n\n        if(this.sendFlag) {\n            throw new Error('INVALID_STATE_ERR: send has already been called');\n        }\n\n        let ssl = false, local = false;\n        const url = Url.parse(this.settings.url);\n        let host;\n\n        // Determine the server\n        switch(url.protocol) {\n            case 'https:':\n                ssl = true;\n                // SSL & non-SSL both need host, no break here.\n            case 'http:':\n                host = url.hostname;\n            break;\n\n            case 'file:':\n                local = true;\n            break;\n\n            case undefined:\n            case null:\n            case '':\n                host = 'localhost';\n            break;\n\n            default:\n                throw new Error('Protocol not supported.');\n        }\n\n        // Load files off the local filesystem (file://)\n        if(local) {\n            if(this.settings.method !== 'GET') {\n                throw new Error('XMLHttpRequest: Only GET method is supported');\n            }\n\n            if(this.settings.async) {\n                fs.readFile(unescape(url.pathname || '/'), 'utf8', function(error: any, fileData: string) {\n                    if(error) {\n                        self.handleError(error);\n                    } else {\n                        self.status = 200;\n                        self.responseText = fileData;\n                        self.setState(self.DONE);\n                    }\n                });\n            } else {\n                try {\n                    this.responseText = fs.readFileSync(unescape(url.pathname || '/'), 'utf8');\n                    this.status = 200;\n                    this.setState(self.DONE);\n                } catch(e) {\n                    this.handleError(e);\n                }\n            }\n\n            return;\n        }\n\n        // Default to port 80. If accessing localhost on another port be sure\n        // to use http://localhost:port/path\n        const port = url.port || (ssl ? 443 : 80);\n\n        // Add query string if one is used\n        const uri = url.pathname + (url.search ? url.search : '');\n\n        // Set the defaults if they haven't been set\n        for(const name in this.defaultHeaders) {\n            if(!this.headersLowerCase[name.toLowerCase()]) {\n                this.headers[name] = this.defaultHeaders[name];\n            }\n        }\n\n        if(host) {\n            // Set the Host header or the server may reject the request\n            this.headers.Host = host;\n        }\n\n        // IPv6 addresses must be escaped with brackets\n        if(url.host && url.host[0] === '[') {\n            this.headers.Host = '[' + this.headers.Host + ']';\n        }\n\n        if(!((ssl && port === 443) || port === 80)) {\n            this.headers.Host += ':' + url.port;\n        }\n\n        // Set Basic Auth if necessary\n        if(this.settings.user) {\n            if(typeof this.settings.password === 'undefined') {\n                this.settings.password = '';\n            }\n            const authBuf = Buffer.from(this.settings.user + ':' + this.settings.password);\n            this.headers.Authorization = 'Basic ' + authBuf.toString('base64');\n        }\n\n        // Set content length header\n        if(this.settings.method === 'GET' || this.settings.method === 'HEAD') {\n            data = null;\n        } else if (data) {\n            this.headers['Content-Length'] = '' + (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));\n\n            if(!this.getRequestHeader('Content-Type')) {\n                this.headers['Content-Type'] = 'text/plain;charset=UTF-8';\n            }\n        } else if (this.settings.method === 'POST') {\n            // For a post with no data set Content-Length: 0.\n            // This is required by buggy servers that don't meet the specs.\n            this.headers['Content-Length'] = '0';\n        }\n\n        const options = {\n            host: host,\n            port: port,\n            path: uri,\n            method: this.settings.method,\n            headers: this.headers,\n            agent: false,\n            withCredentials: this.withCredentials\n        };\n\n        // Reset error flag\n        this.errorFlag = false;\n\n        // Handle async requests\n        if(this.settings.async) {\n            // handle timeouts correctly\n            if(this.timeout >= 1) {\n                this.timeoutTimer = setTimeout(() => {\n                    if(this.readyState !== this.DONE) {\n                        self.handleTimeout(new Error('request timed out after ' + this.timeout + 'ms'));\n                    }\n                }, this.timeout);\n            }\n\n            // Use the proper protocol\n            let doRequest = ssl ? https.request : http.request;\n\n            // Request is being sent, set send flag\n            this.sendFlag = true;\n\n            // As per spec, this is called here for historical reasons.\n            self.dispatchEvent('readystatechange');\n\n            // Error handler for the request\n            const errorHandler = function(error: any) {\n                self.handleError(error);\n            };\n\n            let redirectCount = 0;\n\n            // Handler for the response\n            const responseHandler = function(resp: IncomingMessage) {\n                // Set response let to the response we got back\n                // This is so it remains accessable outside this scope\n                self.response = resp;\n\n                if(self.settings === undefined) {\n                    throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n                }\n\n                // Check for redirect\n                if(\n                    self.response.headers.location && (\n                        self.response.statusCode === 301 ||\n                        self.response.statusCode === 302 ||\n                        self.response.statusCode === 303 ||\n                        self.response.statusCode === 307\n                    )\n                ) {\n                    // increase redirect count\n                    redirectCount++;\n\n                    // prevent looped redirects\n                    if(redirectCount >= 10) {\n                        throw new Error('XMLHttpRequest: Request failed - too many redirects');\n                    }\n\n                    // Change URL to the redirect location\n                    self.settings.url = self.response.headers.location;\n                    const parsedUrl = Url.parse(self.settings.url);\n                    // Set host let in case it's used later\n                    host = parsedUrl.hostname;\n\n                    // Set host parameter for header or redirect won't work\n                    if(host) {\n                        self.headers.Host = host;\n                    }\n\n                    // Options for the new request\n                    const newOptions = {\n                        hostname: parsedUrl.hostname,\n                        port: parsedUrl.port,\n                        path: parsedUrl.path,\n                        method: self.response.statusCode === 303 ? 'GET' : self.settings.method,\n                        headers: self.headers,\n                        withCredentials: self.withCredentials\n                    };\n\n                    // Update ssl and doRequest to be appropriate\n                    // For (potentially) new protocol\n                    ssl = (url.protocol === 'https:' ? true : false);\n                    doRequest = ssl ? https.request : http.request;\n\n                    // Issue the new request\n                    self.request = doRequest(newOptions, responseHandler).on('error', errorHandler);\n                    self.request.end();\n\n                    // @TODO Check if an XHR event needs to be fired here\n                    return;\n                }\n\n                self.response.setEncoding('utf8');\n\n                self.setState(self.HEADERS_RECEIVED);\n                self.status = self.response.statusCode || 0;\n\n                self.response.on('data', function(chunk) {\n                    // Make sure there's some data\n                    if (chunk) {\n                        self.responseText += chunk;\n                    }\n                    // Don't emit state changes if the connection has been aborted.\n                    if(self.sendFlag) {\n                        self.setState(self.LOADING);\n                    }\n                });\n\n                self.response.on('end', function() {\n                    if(self.sendFlag) {\n                        // Discard the end event if the connection has been aborted\n                        self.setState(self.DONE);\n                        self.sendFlag = false;\n                    }\n                });\n\n                self.response.on('error', function(error) {\n                    self.handleError(error);\n                });\n            };\n\n            // Create the request\n            self.request = doRequest(options, responseHandler).on('error', errorHandler);\n\n            // Node 0.4 and later won't accept empty data. Make sure it's needed.\n            if(data) {\n                self.request.write(data);\n            }\n\n            self.request.end();\n\n            self.dispatchEvent('loadstart');\n        } else { // Synchronous\n            const startTime = new Date().getTime();\n\n            // Create a temporary file for communication with the other Node process\n            const contentFile = os.tmpdir() + path.sep + 'ts-xmlhttprequest-content-' + process.pid;\n            const syncFile = os.tmpdir() + path.sep + 'ts-xmlhttprequest-sync-' + process.pid;\n            fs.writeFileSync(syncFile, '', 'utf8');\n\n            // The async request the other Node process executes\n            const execString = 'let http = require(\\'http\\'), https = require(\\'https\\'), fs = require(\\'fs\\');'\n                             + 'let doRequest = http' + (ssl ? 's' : '') + '.request;'\n                             + 'let options = ' + JSON.stringify(options) + ';'\n                             + 'let responseText = \\'\\';'\n                             + 'let req = doRequest(options, function(response) {'\n                             + 'response.setEncoding(\\'utf8\\');'\n                             + 'response.on(\\'data\\', function(chunk) {'\n                             + '    responseText += chunk;'\n                             + '});'\n                             + 'response.on(\\'end\\', function() {'\n                             + 'fs.writeFileSync('\n                             + '    \\'' + contentFile + '\\','\n                             + '    JSON.stringify({'\n                             + '        err: null,'\n                             + '        data: {statusCode: response.statusCode, headers: response.headers, text: responseText}'\n                             + '    }),'\n                             + '    \\'utf8\\''\n                             + ');'\n                             + 'fs.unlinkSync(\\'' + syncFile + '\\');'\n                             + '});'\n                             + 'response.on(\\'error\\', function(error) {'\n                             + 'fs.writeFileSync(\\'' + contentFile + '\\', JSON.stringify({err: error}), \\'utf8\\');'\n                             + 'fs.unlinkSync(\\'' + syncFile + '\\');'\n                             + '});'\n                             + '}).on(\\'error\\', function(error) {'\n                             + 'fs.writeFileSync(\\'' + contentFile + '\\', JSON.stringify({err: error}), \\'utf8\\');'\n                             + 'fs.unlinkSync(\\'' + syncFile + '\\');'\n                             + '});'\n                             + (data ? 'req.write(\\'' + JSON.stringify(data).slice(1, -1).replace(/'/g, '\\\\\\'') + '\\');' : '')\n                             + 'req.end();';\n\n            self.dispatchEvent('loadstart');\n            this.setState(self.LOADING);\n\n            // Start the other Node Process, executing this string\n            const syncProc = spawn(process.argv[0], ['-e', execString]);\n\n            // since this method will run syncronized - this callback always get's called after everything is done\n            syncProc.on('exit', function (code, signal) {\n                // clean up the temp files\n                try { fs.unlinkSync(syncFile); } catch(e) {}\n                try { fs.unlinkSync(contentFile); } catch(e) {}\n            });\n\n            while(fs.existsSync(syncFile)) {\n                if(this.timeout !== 0 && new Date().getTime() >= startTime + this.timeout) {\n                    // kill the process when we face an error\n                    syncProc.stdin.end();\n                    syncProc.kill();\n\n                    // handle the timeout error\n                    return self.handleTimeout(new Error('request timed out after ' + this.timeout + 'ms'));\n                }\n            }\n\n            // Kill the child process once the file has data\n            syncProc.stdin.end();\n            syncProc.kill();\n\n            const resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));\n\n            // Remove the temporary file\n            fs.unlinkSync(contentFile);\n\n            if(resp.err) {\n                self.handleError(resp.err);\n            } else {\n                self.response = resp.data;\n                self.status = resp.data.statusCode;\n                self.responseText = resp.data.text;\n                self.setState(self.DONE);\n            }\n        }\n    }\n\n    /**\n     * aborts a request\n     */\n    public abort() {\n        if(this.request) {\n            this.request.abort();\n            this.request = undefined;\n        }\n\n        this.headers = {};\n        this.status = 0;\n        this.responseText = '';\n        this.responseXML = null;\n\n        this.errorFlag = true;\n\n        if(\n            this.readyState !== this.UNSENT &&\n            (this.readyState !== this.OPENED || this.sendFlag) &&\n            this.readyState !== this.DONE\n        ) {\n            this.sendFlag = false;\n            this.setState(this.DONE);\n        }\n\n        this.readyState = this.UNSENT;\n\n        this.dispatchEvent('abort');\n    }\n\n    /**\n     * adds an event listener to the XMLHttpRequest - this is the preferred method of binding to events\n     */\n    public addEventListener(event: string, callback: (xhr: XMLHttpRequest) => any) {\n        if(!(event in this.listeners)) {\n            this.listeners[event] = [];\n        }\n\n        // Currently allows duplicate callbacks. Should it?\n        this.listeners[event].push(callback);\n    }\n\n    /**\n     * removes an event callback that has been added with the addEventListener method.\n     */\n    public removeEventListener(event: string, callback: (xhr: XMLHttpRequest) => any) {\n        if(event in this.listeners) {\n            // Filter will return a new array with the callback removed\n            this.listeners[event] = this.listeners[event].filter(function(ev: (xhr: XMLHttpRequest) => any) {\n                return ev !== callback;\n            });\n        }\n    }\n\n    /**\n     * dispatches events, including the \"on\" methods and events attached using addEventListener\n     */\n    public dispatchEvent(event: string, parameter?: any) {\n        const eventHandlerMethodName: string = 'on' + event;\n        if(typeof (<any> this)[eventHandlerMethodName] === 'function') {\n            (<any> this)[eventHandlerMethodName](parameter);\n        }\n\n        if(event in this.listeners) {\n            for(let i = 0, len = this.listeners[event].length; i < len; i++) {\n                this.listeners[event][i].call(this, parameter);\n            }\n        }\n    }\n\n    // private instance methods ////////////////////////////////////////////////////////////////////\n\n    /**\n     * changes readyState and calls onreadystatechange\n     */\n    private setState(state: number) {\n        if(state === this.LOADING || this.readyState !== state) {\n            this.readyState = state;\n\n            if((this.settings && this.settings.async) || this.readyState < this.OPENED || this.readyState === this.DONE) {\n                this.dispatchEvent('readystatechange');\n            }\n\n            if(this.readyState === this.DONE) {\n                if(this.timeoutTimer) {\n                    clearTimeout(this.timeoutTimer);\n                    this.timeoutTimer = undefined;\n                }\n\n                if(!this.errorFlag) {\n                    this.dispatchEvent('load');\n                }\n\n                this.dispatchEvent('loadend');\n            }\n        }\n    }\n\n    /**\n     * called when a timeout is encountered\n     */\n    private handleTimeout(error: Error) {\n        if(this.request) {\n            this.request.abort();\n            this.request = undefined;\n        }\n\n        this.status = 0;\n        this.statusText = error.toString();\n        this.responseText = error.stack || '';\n        this.errorFlag = true;\n        this.dispatchEvent('timeout', error);\n        this.setState(this.DONE);\n    }\n\n    /**\n     * called when an error is encountered\n     */\n    private handleError(error: Error) {\n        this.status = 0;\n        this.statusText = error.toString();\n        this.responseText = error.stack || '';\n        this.errorFlag = true;\n        this.dispatchEvent('error', error);\n        this.setState(this.DONE);\n    }\n\n    /**\n     * checks if the specified header is allowed\n     */\n    private isAllowedHttpHeader(header: string): boolean {\n        return (this.disableHeaderCheck || (header && this.forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1)) === true;\n    }\n\n    /**\n     * checks if the specified request method is allowed\n     */\n    private isAllowedHttpMethod(method: string): boolean {\n        return (method && this.forbiddenRequestMethods.indexOf(method) === -1) === true;\n    }\n}"],"names":["url","Url.parse","fs.readFile","fs.readFileSync","https.request","http.request","os.tmpdir","path.sep","fs.writeFileSync","spawn","fs.unlinkSync","fs.existsSync"],"mappings":"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"}