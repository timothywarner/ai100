{"version":3,"file":"xmlhttprequest-ts.js","sources":["../../src/XMLHttpRequest.ts"],"sourcesContent":["// import required node.js core dependencies ///////////////////////////////////////////////////////\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport * as Url from 'url';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { ClientRequest, IncomingMessage } from 'http';\nimport { spawn } from 'child_process';\n\n// import required local dependencies //////////////////////////////////////////////////////////////\nimport { HttpHeaders } from './HttpHeaders';\nimport { XMLHttpRequestSettings } from './XMLHttpRequestSettings';\nimport { XMLHttpRequestListeners } from './XMLHttpRequestListeners';\n\n/**\n * defines the node implementaton of the XMLHttpRequest object specs\n *\n * see: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */\nexport class XMLHttpRequest {\n    // class constants /////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * constant representing the state an XMLHttpRequest is in after being constructed\n     */\n    public static UNSENT = 0;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in after 'open' was called\n     */\n    public static OPENED = 1;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when all response headers have been received\n     */\n    public static HEADERS_RECEIVED = 2;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when either the data transfer has been completed or something went wrong\n     */\n    public static LOADING = 3;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when the response entity body is being received\n     */\n    public static DONE = 4;\n\n    // instance constants //////////////////////////////////////////////////////////////////////////\n\n    /**\n     * constant representing the state an XMLHttpRequest is in after being constructed\n     */\n    public UNSENT = XMLHttpRequest.UNSENT;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in after 'open' was called\n     */\n    public OPENED = XMLHttpRequest.OPENED;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when all response headers have been received\n     */\n    public HEADERS_RECEIVED = XMLHttpRequest.HEADERS_RECEIVED;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when either the data transfer has been completed or something went wrong\n     */\n    public LOADING = XMLHttpRequest.LOADING;\n\n    /**\n     * constant representing the state an XMLHttpRequest is in when the response entity body is being received\n     */\n    public DONE = XMLHttpRequest.DONE;\n\n    // public instance members /////////////////////////////////////////////////////////////////////\n\n    /**\n     * option to disable the builtin header blacklist\n     *\n     * IMPORTANT: this is not part of the XHR specs\n     */\n    public disableHeaderCheck = false;\n\n    /**\n     * an EventHandler that is called whenever the readyState attribute changes\n     */\n    public onreadystatechange?: () => any;\n\n    /**\n     * an EventHandler that is called whenever an abort occurs\n     */\n    public onabort?: () => any;\n\n    /**\n     * an EventHandler that is called whenever an error occurs\n     */\n    public onerror?: (err: Error) => any;\n\n    /**\n     * an EventHandler that is called whenever a request loads successfully\n     */\n    public onload?: () => any;\n\n    /**\n     * an EventHandler that is called whenever a request finished\n     */\n    public onloadend?: () => any;\n\n    /**\n     * an EventHandler that is called whenever a request starts to load\n     */\n    public onloadstart?: () => any;\n\n    /**\n     * an EventHandler that is called whenever a timeout occurs\n     */\n    public ontimeout?: (err: Error) => any;\n\n    /**\n     * stores the ready state of the request (see UNSENT, OPENED, HEADERS_RECEIVED, LOADING, DONE)\n     */\n    public readyState = XMLHttpRequest.UNSENT;\n\n    /**\n     * the text received from a server following a request being sent\n     */\n    public responseText = '';\n\n    /**\n     * usually contains a document instance of the parsed request result but since the dom isn't available in node, this is always null\n     */\n    public responseXML: null = null;\n\n    /**\n     * the numerical status code of the response\n     */\n    public status = 0;\n\n    /**\n     * the text received from a server following a request being sent\n     */\n    public statusText = '';\n\n    /**\n     * timeout in milliseconds after a request should time out\n     */\n    public timeout = 0;\n\n    /**\n     * indicates whether or not cross-site Access-Control requests should be made using credentials like authorization headers\n     */\n    public withCredentials = false;\n\n    // private instance members ////////////////////////////////////////////////////////////////////\n\n    /**\n     * defines the default headers sent by our requests\n     */\n    private defaultHeaders: HttpHeaders = {\n        'User-Agent': 'ts-XMLHttpRequest',\n        'Accept': '*/*'\n    };\n\n    /**\n     * error flag, used when errors occur or abort is called\n     */\n    private errorFlag = false;\n\n    /**\n     * list of headers that are not setable by the user according to the specs\n     *\n     * IMPORTNAT: this can optionally be disabled by setting disableHeaderCheck to true\n     */\n    private forbiddenRequestHeaders: Array<string> = [\n        'accept-charset',\n        'accept-encoding',\n        'access-control-request-headers',\n        'access-control-request-method',\n        'connection',\n        'content-length',\n        'content-transfer-encoding',\n        'cookie',\n        'cookie2',\n        'date',\n        'expect',\n        'host',\n        'keep-alive',\n        'origin',\n        'referer',\n        'te',\n        'trailer',\n        'transfer-encoding',\n        'upgrade',\n        'via'\n    ];\n\n    /**\n     * list of request methods that are not setable by the user according to the specs\n     */\n    private forbiddenRequestMethods: Array<string> = [\n        'TRACE',\n        'TRACK',\n        'CONNECT'\n    ];\n\n    /**\n     * stores the headers that are used for this request\n     */\n    private headers: HttpHeaders = {};\n\n    /**\n     * stores the headers that are used for this request with the name being lower-cased\n     */\n    private headersLowerCase: HttpHeaders = {};\n\n    /**\n     * stores the event listeners that have been set via the addEventListener method\n     */\n    private listeners: XMLHttpRequestListeners = {};\n\n    /**\n     * stores a reference to the request object of node.js\n     */\n    private request?: ClientRequest;\n\n    /**\n     * stores a reference to the response object of node.js\n     */\n    private response?: IncomingMessage;\n\n    /**\n     * flag indicating if a request was sent already\n     */\n    private sendFlag = false;\n\n    /**\n     * stores the settings of this object which are set when calling \"open\"\n     */\n    private settings?: XMLHttpRequestSettings;\n\n    /**\n     * stores the timer that is used for timeouts\n     */\n    timeoutTimer?: NodeJS.Timer;\n\n    // public instance methods /////////////////////////////////////////////////////////////////////\n\n    /**\n     * Open the connection. Currently supports local server requests.\n     *\n     * @param method Connection method (eg GET, POST)\n     * @param url URL for the connection.\n     * @param async Asynchronous connection (optional - default is true)\n     * @param user Username for basic authentication (optional)\n     * @param password Password for basic authentication (optional)\n     */\n    public open(method: string, url: string, async: boolean = true, user?: string, password?: string) {\n        this.abort();\n\n        this.errorFlag = false;\n\n        // Check for valid request method\n        if(!this.isAllowedHttpMethod(method)) {\n            throw new Error('SecurityError: Request method not allowed');\n        }\n\n        this.settings = {\n            'method': method,\n            'url': url,\n            'async': (typeof async !== 'boolean' ? true : async),\n            'user': user,\n            'password': password\n        };\n\n        this.setState(this.OPENED);\n    }\n\n    /**\n     * disables or enables the check of allowed headers in the request\n     *\n     * IMPORTANT: this is not part of the W3C spec\n     *\n     * @param state Enable or disable header checking.\n     */\n    public setDisableHeaderCheck(state: boolean): void {\n        this.disableHeaderCheck = state;\n    }\n\n    /**\n     * sets a header for the request or appends the value if one is already set\n     *\n     * @param header header name\n     * @param value header value\n     */\n    public setRequestHeader(header: string, value: string) {\n        if(this.readyState !== this.OPENED) {\n            throw new Error('INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN');\n        }\n\n        if(!this.isAllowedHttpHeader(header)) {\n            console.warn('Refused to set unsafe header \\\"' + header + '\\\"');\n\n            return;\n        }\n\n        if(this.sendFlag) {\n            throw new Error('INVALID_STATE_ERR: send flag is true');\n        }\n\n        header = this.headersLowerCase[header.toLowerCase()] || header;\n        this.headersLowerCase[header.toLowerCase()] = header;\n        this.headers[header] = this.headers[header] ? this.headers[header] + ', ' + value : value;\n    }\n\n    /**\n     * returns all the response headers, separated by CRLF, as a string, or null if no response has been received\n     *\n     * @return a string with all response headers separated by CR+LF, or null if no response has been received\n     */\n    public getAllResponseHeaders() {\n        if(this.readyState < this.HEADERS_RECEIVED || this.errorFlag) {\n            return null;\n        }\n\n        let result = '';\n        if(this.response) {\n            for(const i in this.response.headers) {\n                // Cookie headers are excluded\n                if(i !== 'set-cookie' && i !== 'set-cookie2') {\n                    const headerValue: string | Array<string> | undefined = this.response.headers[i];\n\n                    if(typeof headerValue === 'string') {\n                        result += i + ': ' + headerValue + '\\r\\n';\n                    } else if(Array.isArray(headerValue)) {\n                        result += i + ': ' + headerValue.join(', ') + '\\r\\n';\n                    } else {\n                        result += i + ':\\r\\n';\n                    }\n                }\n            }\n        }\n\n        return result.substr(0, result.length - 2);\n    }\n\n    /**\n     * gets a header from the server response.\n     *\n     * @return text of the header or null if it doesn't exist.\n     */\n    public getResponseHeader(header: string): string | null {\n        if(\n            typeof header === 'string' &&\n            this.readyState > this.OPENED &&\n            this.response &&\n            this.response.headers &&\n            this.response.headers[header.toLowerCase()] &&\n            !this.errorFlag\n        ) {\n            const responseHeader: string | string[] | undefined = this.response.headers[header.toLowerCase()];\n\n            if(typeof responseHeader === 'string') {\n                return responseHeader;\n            }\n\n            if(Array.isArray(responseHeader)) {\n                return responseHeader.join(', ');\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * gets a request header that was set in this instance\n     *\n     * IMPORTANT: this is not part of the W3C specs\n     *\n     * @return returns the request header or empty string if not set\n     */\n    public getRequestHeader(name: string): string | undefined {\n        if(typeof name === 'string' && this.headersLowerCase[name.toLowerCase()]) {\n            return this.headers[this.headersLowerCase[name.toLowerCase()]];\n        }\n\n        return undefined;\n    }\n\n    /**\n     * sends the request to the server.\n     *\n     * @param string data Optional data to send as request body.\n     */\n    public send(data?: any) {\n        const self = this;\n\n        if(this.settings === undefined) {\n            throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n        }\n\n        if(this.readyState !== this.OPENED) {\n            throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n        }\n\n        if(this.sendFlag) {\n            throw new Error('INVALID_STATE_ERR: send has already been called');\n        }\n\n        let ssl = false, local = false;\n        const url = Url.parse(this.settings.url);\n        let host;\n\n        // Determine the server\n        switch(url.protocol) {\n            case 'https:':\n                ssl = true;\n                // SSL & non-SSL both need host, no break here.\n            case 'http:':\n                host = url.hostname;\n            break;\n\n            case 'file:':\n                local = true;\n            break;\n\n            case undefined:\n            case null:\n            case '':\n                host = 'localhost';\n            break;\n\n            default:\n                throw new Error('Protocol not supported.');\n        }\n\n        // Load files off the local filesystem (file://)\n        if(local) {\n            if(this.settings.method !== 'GET') {\n                throw new Error('XMLHttpRequest: Only GET method is supported');\n            }\n\n            if(this.settings.async) {\n                fs.readFile(unescape(url.pathname || '/'), 'utf8', function(error: any, fileData: string) {\n                    if(error) {\n                        self.handleError(error);\n                    } else {\n                        self.status = 200;\n                        self.responseText = fileData;\n                        self.setState(self.DONE);\n                    }\n                });\n            } else {\n                try {\n                    this.responseText = fs.readFileSync(unescape(url.pathname || '/'), 'utf8');\n                    this.status = 200;\n                    this.setState(self.DONE);\n                } catch(e) {\n                    this.handleError(e);\n                }\n            }\n\n            return;\n        }\n\n        // Default to port 80. If accessing localhost on another port be sure\n        // to use http://localhost:port/path\n        const port = url.port || (ssl ? 443 : 80);\n\n        // Add query string if one is used\n        const uri = url.pathname + (url.search ? url.search : '');\n\n        // Set the defaults if they haven't been set\n        for(const name in this.defaultHeaders) {\n            if(!this.headersLowerCase[name.toLowerCase()]) {\n                this.headers[name] = this.defaultHeaders[name];\n            }\n        }\n\n        if(host) {\n            // Set the Host header or the server may reject the request\n            this.headers.Host = host;\n        }\n\n        // IPv6 addresses must be escaped with brackets\n        if(url.host && url.host[0] === '[') {\n            this.headers.Host = '[' + this.headers.Host + ']';\n        }\n\n        if(!((ssl && port === 443) || port === 80)) {\n            this.headers.Host += ':' + url.port;\n        }\n\n        // Set Basic Auth if necessary\n        if(this.settings.user) {\n            if(typeof this.settings.password === 'undefined') {\n                this.settings.password = '';\n            }\n            const authBuf = Buffer.from(this.settings.user + ':' + this.settings.password);\n            this.headers.Authorization = 'Basic ' + authBuf.toString('base64');\n        }\n\n        // Set content length header\n        if(this.settings.method === 'GET' || this.settings.method === 'HEAD') {\n            data = null;\n        } else if (data) {\n            this.headers['Content-Length'] = '' + (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));\n\n            if(!this.getRequestHeader('Content-Type')) {\n                this.headers['Content-Type'] = 'text/plain;charset=UTF-8';\n            }\n        } else if (this.settings.method === 'POST') {\n            // For a post with no data set Content-Length: 0.\n            // This is required by buggy servers that don't meet the specs.\n            this.headers['Content-Length'] = '0';\n        }\n\n        const options = {\n            host: host,\n            port: port,\n            path: uri,\n            method: this.settings.method,\n            headers: this.headers,\n            agent: false,\n            withCredentials: this.withCredentials\n        };\n\n        // Reset error flag\n        this.errorFlag = false;\n\n        // Handle async requests\n        if(this.settings.async) {\n            // handle timeouts correctly\n            if(this.timeout >= 1) {\n                this.timeoutTimer = setTimeout(() => {\n                    if(this.readyState !== this.DONE) {\n                        self.handleTimeout(new Error('request timed out after ' + this.timeout + 'ms'));\n                    }\n                }, this.timeout);\n            }\n\n            // Use the proper protocol\n            let doRequest = ssl ? https.request : http.request;\n\n            // Request is being sent, set send flag\n            this.sendFlag = true;\n\n            // As per spec, this is called here for historical reasons.\n            self.dispatchEvent('readystatechange');\n\n            // Error handler for the request\n            const errorHandler = function(error: any) {\n                self.handleError(error);\n            };\n\n            let redirectCount = 0;\n\n            // Handler for the response\n            const responseHandler = function(resp: IncomingMessage) {\n                // Set response let to the response we got back\n                // This is so it remains accessable outside this scope\n                self.response = resp;\n\n                if(self.settings === undefined) {\n                    throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called');\n                }\n\n                // Check for redirect\n                if(\n                    self.response.headers.location && (\n                        self.response.statusCode === 301 ||\n                        self.response.statusCode === 302 ||\n                        self.response.statusCode === 303 ||\n                        self.response.statusCode === 307\n                    )\n                ) {\n                    // increase redirect count\n                    redirectCount++;\n\n                    // prevent looped redirects\n                    if(redirectCount >= 10) {\n                        throw new Error('XMLHttpRequest: Request failed - too many redirects');\n                    }\n\n                    // Change URL to the redirect location\n                    self.settings.url = self.response.headers.location;\n                    const parsedUrl = Url.parse(self.settings.url);\n                    // Set host let in case it's used later\n                    host = parsedUrl.hostname;\n\n                    // Set host parameter for header or redirect won't work\n                    if(host) {\n                        self.headers.Host = host;\n                    }\n\n                    // Options for the new request\n                    const newOptions = {\n                        hostname: parsedUrl.hostname,\n                        port: parsedUrl.port,\n                        path: parsedUrl.path,\n                        method: self.response.statusCode === 303 ? 'GET' : self.settings.method,\n                        headers: self.headers,\n                        withCredentials: self.withCredentials\n                    };\n\n                    // Update ssl and doRequest to be appropriate\n                    // For (potentially) new protocol\n                    ssl = (url.protocol === 'https:' ? true : false);\n                    doRequest = ssl ? https.request : http.request;\n\n                    // Issue the new request\n                    self.request = doRequest(newOptions, responseHandler).on('error', errorHandler);\n                    self.request.end();\n\n                    // @TODO Check if an XHR event needs to be fired here\n                    return;\n                }\n\n                self.response.setEncoding('utf8');\n\n                self.setState(self.HEADERS_RECEIVED);\n                self.status = self.response.statusCode || 0;\n\n                self.response.on('data', function(chunk) {\n                    // Make sure there's some data\n                    if (chunk) {\n                        self.responseText += chunk;\n                    }\n                    // Don't emit state changes if the connection has been aborted.\n                    if(self.sendFlag) {\n                        self.setState(self.LOADING);\n                    }\n                });\n\n                self.response.on('end', function() {\n                    if(self.sendFlag) {\n                        // Discard the end event if the connection has been aborted\n                        self.setState(self.DONE);\n                        self.sendFlag = false;\n                    }\n                });\n\n                self.response.on('error', function(error) {\n                    self.handleError(error);\n                });\n            };\n\n            // Create the request\n            self.request = doRequest(options, responseHandler).on('error', errorHandler);\n\n            // Node 0.4 and later won't accept empty data. Make sure it's needed.\n            if(data) {\n                self.request.write(data);\n            }\n\n            self.request.end();\n\n            self.dispatchEvent('loadstart');\n        } else { // Synchronous\n            const startTime = new Date().getTime();\n\n            // Create a temporary file for communication with the other Node process\n            const contentFile = os.tmpdir() + path.sep + 'ts-xmlhttprequest-content-' + process.pid;\n            const syncFile = os.tmpdir() + path.sep + 'ts-xmlhttprequest-sync-' + process.pid;\n            fs.writeFileSync(syncFile, '', 'utf8');\n\n            // The async request the other Node process executes\n            const execString = 'let http = require(\\'http\\'), https = require(\\'https\\'), fs = require(\\'fs\\');'\n                             + 'let doRequest = http' + (ssl ? 's' : '') + '.request;'\n                             + 'let options = ' + JSON.stringify(options) + ';'\n                             + 'let responseText = \\'\\';'\n                             + 'let req = doRequest(options, function(response) {'\n                             + 'response.setEncoding(\\'utf8\\');'\n                             + 'response.on(\\'data\\', function(chunk) {'\n                             + '    responseText += chunk;'\n                             + '});'\n                             + 'response.on(\\'end\\', function() {'\n                             + 'fs.writeFileSync('\n                             + '    \\'' + contentFile + '\\','\n                             + '    JSON.stringify({'\n                             + '        err: null,'\n                             + '        data: {statusCode: response.statusCode, headers: response.headers, text: responseText}'\n                             + '    }),'\n                             + '    \\'utf8\\''\n                             + ');'\n                             + 'fs.unlinkSync(\\'' + syncFile + '\\');'\n                             + '});'\n                             + 'response.on(\\'error\\', function(error) {'\n                             + 'fs.writeFileSync(\\'' + contentFile + '\\', JSON.stringify({err: error}), \\'utf8\\');'\n                             + 'fs.unlinkSync(\\'' + syncFile + '\\');'\n                             + '});'\n                             + '}).on(\\'error\\', function(error) {'\n                             + 'fs.writeFileSync(\\'' + contentFile + '\\', JSON.stringify({err: error}), \\'utf8\\');'\n                             + 'fs.unlinkSync(\\'' + syncFile + '\\');'\n                             + '});'\n                             + (data ? 'req.write(\\'' + JSON.stringify(data).slice(1, -1).replace(/'/g, '\\\\\\'') + '\\');' : '')\n                             + 'req.end();';\n\n            self.dispatchEvent('loadstart');\n            this.setState(self.LOADING);\n\n            // Start the other Node Process, executing this string\n            const syncProc = spawn(process.argv[0], ['-e', execString]);\n\n            // since this method will run syncronized - this callback always get's called after everything is done\n            syncProc.on('exit', function (code, signal) {\n                // clean up the temp files\n                try { fs.unlinkSync(syncFile); } catch(e) {}\n                try { fs.unlinkSync(contentFile); } catch(e) {}\n            });\n\n            while(fs.existsSync(syncFile)) {\n                if(this.timeout !== 0 && new Date().getTime() >= startTime + this.timeout) {\n                    // kill the process when we face an error\n                    syncProc.stdin.end();\n                    syncProc.kill();\n\n                    // handle the timeout error\n                    return self.handleTimeout(new Error('request timed out after ' + this.timeout + 'ms'));\n                }\n            }\n\n            // Kill the child process once the file has data\n            syncProc.stdin.end();\n            syncProc.kill();\n\n            const resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));\n\n            // Remove the temporary file\n            fs.unlinkSync(contentFile);\n\n            if(resp.err) {\n                self.handleError(resp.err);\n            } else {\n                self.response = resp.data;\n                self.status = resp.data.statusCode;\n                self.responseText = resp.data.text;\n                self.setState(self.DONE);\n            }\n        }\n    }\n\n    /**\n     * aborts a request\n     */\n    public abort() {\n        if(this.request) {\n            this.request.abort();\n            this.request = undefined;\n        }\n\n        this.headers = {};\n        this.status = 0;\n        this.responseText = '';\n        this.responseXML = null;\n\n        this.errorFlag = true;\n\n        if(\n            this.readyState !== this.UNSENT &&\n            (this.readyState !== this.OPENED || this.sendFlag) &&\n            this.readyState !== this.DONE\n        ) {\n            this.sendFlag = false;\n            this.setState(this.DONE);\n        }\n\n        this.readyState = this.UNSENT;\n\n        this.dispatchEvent('abort');\n    }\n\n    /**\n     * adds an event listener to the XMLHttpRequest - this is the preferred method of binding to events\n     */\n    public addEventListener(event: string, callback: (xhr: XMLHttpRequest) => any) {\n        if(!(event in this.listeners)) {\n            this.listeners[event] = [];\n        }\n\n        // Currently allows duplicate callbacks. Should it?\n        this.listeners[event].push(callback);\n    }\n\n    /**\n     * removes an event callback that has been added with the addEventListener method.\n     */\n    public removeEventListener(event: string, callback: (xhr: XMLHttpRequest) => any) {\n        if(event in this.listeners) {\n            // Filter will return a new array with the callback removed\n            this.listeners[event] = this.listeners[event].filter(function(ev: (xhr: XMLHttpRequest) => any) {\n                return ev !== callback;\n            });\n        }\n    }\n\n    /**\n     * dispatches events, including the \"on\" methods and events attached using addEventListener\n     */\n    public dispatchEvent(event: string, parameter?: any) {\n        const eventHandlerMethodName: string = 'on' + event;\n        if(typeof (<any> this)[eventHandlerMethodName] === 'function') {\n            (<any> this)[eventHandlerMethodName](parameter);\n        }\n\n        if(event in this.listeners) {\n            for(let i = 0, len = this.listeners[event].length; i < len; i++) {\n                this.listeners[event][i].call(this, parameter);\n            }\n        }\n    }\n\n    // private instance methods ////////////////////////////////////////////////////////////////////\n\n    /**\n     * changes readyState and calls onreadystatechange\n     */\n    private setState(state: number) {\n        if(state === this.LOADING || this.readyState !== state) {\n            this.readyState = state;\n\n            if((this.settings && this.settings.async) || this.readyState < this.OPENED || this.readyState === this.DONE) {\n                this.dispatchEvent('readystatechange');\n            }\n\n            if(this.readyState === this.DONE) {\n                if(this.timeoutTimer) {\n                    clearTimeout(this.timeoutTimer);\n                    this.timeoutTimer = undefined;\n                }\n\n                if(!this.errorFlag) {\n                    this.dispatchEvent('load');\n                }\n\n                this.dispatchEvent('loadend');\n            }\n        }\n    }\n\n    /**\n     * called when a timeout is encountered\n     */\n    private handleTimeout(error: Error) {\n        if(this.request) {\n            this.request.abort();\n            this.request = undefined;\n        }\n\n        this.status = 0;\n        this.statusText = error.toString();\n        this.responseText = error.stack || '';\n        this.errorFlag = true;\n        this.dispatchEvent('timeout', error);\n        this.setState(this.DONE);\n    }\n\n    /**\n     * called when an error is encountered\n     */\n    private handleError(error: Error) {\n        this.status = 0;\n        this.statusText = error.toString();\n        this.responseText = error.stack || '';\n        this.errorFlag = true;\n        this.dispatchEvent('error', error);\n        this.setState(this.DONE);\n    }\n\n    /**\n     * checks if the specified header is allowed\n     */\n    private isAllowedHttpHeader(header: string): boolean {\n        return (this.disableHeaderCheck || (header && this.forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1)) === true;\n    }\n\n    /**\n     * checks if the specified request method is allowed\n     */\n    private isAllowedHttpMethod(method: string): boolean {\n        return (method && this.forbiddenRequestMethods.indexOf(method) === -1) === true;\n    }\n}"],"names":["Url.parse","fs.readFile","fs.readFileSync","https.request","http.request","os.tmpdir","path.sep","fs.writeFileSync","fs.unlinkSync","fs.existsSync"],"mappings":"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"}